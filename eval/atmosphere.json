    {
        "readInt": "\n        if (pointer + 4 > size) {\n            throw new EOFException();\n        }\n        return (read() << 24) +\n                (read() << 16) +\n                (read() << 8) +\n                read();\n    ",
        "getSchema": "\n        return DebugSamplerSchema.INSTANCE;\n    ",
        "writeError": "\n            return this;\n        ",
        "setAlias": "\n        String mode = getShareMode();\n        int modeInt = CSVDataSetBeanInfo.getShareModeAsInt(mode);\n        switch(modeInt){\n            case CSVDataSetBeanInfo.SHARE_ALL:\n                this.alias = alias;\n                break;\n            case CSVDataSetBeanInfo.SHARE_GROUP:\n                this.alias = alias + \"@\" + System.identityHashCode(context.getThreadGroup());\n                break;\n            case CSVDataSetBeanInfo.SHARE_THREAD:\n                this.alias = alias + \"@\" + System.identityHashCode(context.getThread());\n                break;\n            default:\n                this.alias = alias + \"@\" + mode; // user-specified key\n                break;\n        }\n    ",
        "actionContinueCreatedTest": "\n        framework.addAtmosphereHandler(\"/*\", handler);\n        framework.interceptor(new AtmosphereInterceptor() {\n            @Override\n            public void configure(AtmosphereConfig config) {\n            }\n            @Override\n            public void destroy() {\n            }\n            @Override\n            public Action inspect(AtmosphereResource r) {\n                // Default is CREATED\n                AtmosphereResourceImpl.class.cast(r).action().type(Action.TYPE.CONTINUE);\n                return Action.CONTINUE;\n            }\n\n            @Override\n            public void postInspect(AtmosphereResource r) {\n            }\n        });\n\n        assertEquals(Action.CONTINUE, processor.service(mock(AtmosphereRequestImpl.class), AtmosphereResponseImpl.newInstance()));\n        framework.interceptor(new AtmosphereInterceptor() {\n            @Override\n            public void configure(AtmosphereConfig config) {\n            }\n            @Override\n            public void destroy() {\n            }\n            @Override\n            public Action inspect(AtmosphereResource r) {\n                // Default is CREATED\n                AtmosphereResourceImpl.class.cast(r).action().type(Action.TYPE.CREATED);\n                return Action.CONTINUE;\n            }\n\n            @Override\n            public void postInspect(AtmosphereResource r) {\n            }\n        });\n        assertEquals(Action.CREATED, processor.service(mock(AtmosphereRequestImpl.class), AtmosphereResponseImpl.newInstance()));\n    ",
        "testResponseWritingBufferedReset": "\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        AtmosphereRequest request =  mock(AtmosphereRequestImpl.class);\n        when(request.getAttribute(ApplicationConfig.RESPONSE_COMPLETION_AWARE)).thenReturn(Boolean.TRUE);\n        when(request.getAttribute(ApplicationConfig.RESPONSE_COMPLETION_RESET)).thenReturn(Boolean.TRUE);\n        AtmosphereResponse response = new AtmosphereResponseImpl.Builder()\n                .request(request).asyncIOWriter(new TestAsyncIOWriter(baos)).build();\n        response.getOutputStream();\n        response.write(\"hello\".getBytes());\n        // buffering the data and nothing written\n        assertEquals(baos.toString(), \"\");\n        response.write(\"hello again\".getBytes());\n        // buffering the new data and writing the previously buffered data\n        assertEquals(baos.toString(), \"hello\");\n        ((AtmosphereResponseImpl)response).onComplete();\n        // the buffered data is written\n        assertEquals(baos.toString(), \"hellohello again\");\n        response.write(\"bye\".getBytes());\n        // written buffered again\n        assertEquals(baos.toString(), \"hellohello again\");\n        response.write(\"bye again\".getBytes());\n        // the buffered data is written\n        assertEquals(baos.toString(), \"hellohello againbye\");\n        ((AtmosphereResponseImpl)response).onComplete();\n        // the buffered data is flushed\n        assertEquals(baos.toString(), \"hellohello againbyebye again\");\n    ",
        "iterationStart": "\n        if (log.isDebugEnabled()) {\n            log.debug(\"{} iteration start {}\", Thread.currentThread().getName(), isPerIteration());//$NON-NLS-1$\n        }\n        if (isPerIteration()) {\n            setValues();\n        }\n    ",
        "scan": "\n        return this;\n    ",
        "getContainerName": "@link ServletConfig}\n     *\n     * @param sc the {@link ServletConfig",
        "getInitFileProperty": "\n        return INIT_FILE;\n    ",
        "dispatchReader": "\n        int read = 0;\n        CharBuffer cb = webSocket.cb;\n        try {\n            while (read > -1) {\n                ((Buffer)cb).position(cb.position() + read);\n                if (cb.remaining() == 0) {\n                    cb = resizeCharBuffer(webSocket);\n                }\n                read = r.read(cb.array(), cb.position(), cb.remaining());\n            }\n            ((Buffer)cb).flip();\n            invokeWebSocketProtocol(webSocket, cb.toString());\n        } finally {\n            ((Buffer)cb).clear();\n        }\n    ",
        "actionCreatedTest": "\n        framework.addAtmosphereHandler(\"/*\", handler);\n        framework.interceptor(new AtmosphereInterceptor() {\n            @Override\n            public void configure(AtmosphereConfig config) {\n            }\n            @Override\n            public void destroy() {\n            }\n            @Override\n            public Action inspect(AtmosphereResource r) {\n                return Action.CREATED;\n            }\n\n            @Override\n            public void postInspect(AtmosphereResource r) {\n            }\n        });\n\n        assertEquals(Action.CREATED, processor.service(mock(AtmosphereRequestImpl.class), AtmosphereResponseImpl.newInstance()));\n    ",
        "readServiceFile": "\n        final Map<String, AtmosphereFramework.MetaServiceAction> b = new LinkedHashMap<>();\n\n        String line;\n        InputStream is = null;\n        BufferedReader reader = null;\n        AtmosphereFramework.MetaServiceAction action = AtmosphereFramework.MetaServiceAction.INSTALL;\n\n        try {\n            is = AtmosphereFramework.class.getClassLoader().getResourceAsStream(path);\n\n            if (is == null) {\n                logger.trace(\"META-INF/services/{} not found in class loader\", path);\n                return b;\n            }\n\n            reader = new BufferedReader(new InputStreamReader(is));\n\n            while (true) {\n                line = reader.readLine();\n\n                if (line == null) {\n                    break;\n                } else if (line.isEmpty()) {\n                } else if (line.indexOf('.') == -1) {\n                    action = AtmosphereFramework.MetaServiceAction.valueOf(line);\n                } else {\n                    b.put(line, action);\n                }\n            }\n            logger.info(\"Successfully loaded and installed {}\", path);\n        } catch (IOException e) {\n            logger.trace(\"Unable to read META-INF/services/{} from class loader\", path, e);\n        } finally {\n            close(is, reader);\n        }\n\n        return b;\n    }\n\n    /**\n     * <p>\n     * Tries to close the given objects and log the {@link IOException} at INFO level\n     * to make the code more readable when we assume that the {@link IOException} won't be managed.\n     * </p>\n     * <p/>\n     * <p>\n     * Also ignore {@code null",
        "setBroadcaster": "\n        this.broadcaster = broadcaster;\n    ",
        "readSuperClass": "\n        di.skipBytes(2); // u2\n    ",
        "isRootFile": "\n        if (current == null) {\n            throw new NoSuchElementException();\n        }\n        return stack.size() < rootCount;\n    }\n\n    /**\n     * Return the next {@link java.io.File} object or {@code null",
        "resetCurrent": "\n        if (getSubControllers().isEmpty()) {\n            current = 0;\n        } else {\n            current = ThreadLocalRandom.current().nextInt(this.getSubControllers().size());\n        }\n    ",
        "getInitParameter": "\n                        return null;\n                    ",
        "getPreload": "\n        return preload;\n    ",
        "capitalize": "\n        if (name == null || name.length() == 0) {\n            return name;\n        }\n        char chars[] = name.toCharArray();\n        chars[0] = Character.toUpperCase(chars[0]);\n        return new String(chars);\n    ",
        "isTerminated": "\n        return false;\n    ",
        "getLeftBoundary": "\n        return getPropertyAsString(L_BOUNDARY);\n    ",
        "setDelimiter": "\n        this.delimiter = delimiter;\n    ",
        "testPathVar": "\n        instanceCount = 0;\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/pathVar/aaa/pathTest/b123\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        assertEquals(instanceCount, 1);\n        assertNotNull(r.get());\n        assertEquals(r.get(), \"aaa#b123\");\n\n    }\n\n    @ManagedService(path = \"/inject/{inject",
        "getTemplateVariables": "\n        return templateVariables;\n    ",
        "testOnBroadcast": "\n        framework.addAtmosphereHandler(\"/*\", new BAR()).init();\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/a\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        assertEquals(BAR.count.get(), 1);\n    ",
        "realPath": "\n        String realPath = servletContext.getRealPath(targetPath);\n        if (realPath == null) {\n            URL u = servletContext.getResource(targetPath);\n            if (u != null) {\n                realPath = u.getPath();\n            } else {\n                return \"\";\n            }\n        }\n        return realPath;\n    ",
        "onPostDestroy": "\n                count.incrementAndGet();\n            }\n        ",
        "cancelF": "\n        try {\n            Future<?> f = (Future<?>) request.getAttribute(HEARTBEAT_FUTURE);\n            if (f != null) f.cancel(false);\n            request.removeAttribute(HEARTBEAT_FUTURE);\n        } catch (Exception ex) {\n            // https://github.com/Atmosphere/atmosphere/issues/1503\n            logger.trace(\"\", ex);\n        }\n    ",
        "alreadyQuoted": "\n        if (value == null || value.length() < 2) {\n            return false;\n        }\n        return (value.charAt(0) == '\\\"' && value.charAt(value.length() - 1) == '\\\"');\n    ",
        "getCometContext": "\n            return cometContext;\n        ",
        "transform": "\n        AsyncIOWriter a = response.getAsyncIOWriter();\n        // NOTE #1961 for now, create a new buffer par transform call and release it after the transform call.\n        //      Alternatively, we may cache the buffer in thread-local and use it while this thread invokes\n        //      multiple writes and release it when this thread invokes the close method.\n        ByteArrayAsyncWriter buffer = new ByteArrayAsyncWriter();\n        try {\n            response.asyncIOWriter(buffer);\n            invokeInterceptor(response, b, offset, length);\n            return buffer.stream().toByteArray();\n        } finally {\n            buffer.close(null);\n            response.asyncIOWriter(a);\n        }\n    ",
        "testManagedManagedDoublePathMessage": "\n        instanceCount = 0;\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/foo/bar/yo\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        assertEquals(instanceCount, 1);\n        assertNotNull(r.get());\n        assertEquals(r.get(), \"/foo/bar/yo\");\n\n    }\n\n    @WebSocketHandlerService(path = \"/ws/{g",
        "initCookie": "\n            if (nameBegin == -1 || nameBegin == nameEnd) {\n                return null;\n            }\n\n            if (valueBegin == -1) {\n                return null;\n            }\n\n            CharSequence wrappedValue = CharBuffer.wrap(header, valueBegin, valueEnd);\n            CharSequence unwrappedValue = unwrapValue(wrappedValue);\n            if (unwrappedValue == null) {\n                return null;\n            }\n\n            final String name = header.substring(nameBegin, nameEnd);\n\n            if (strict && firstInvalidCookieNameOctet(name) >= 0) {\n                return null;\n            }\n\n            if (strict && firstInvalidCookieValueOctet(unwrappedValue) >= 0) {\n                return null;\n            }\n\n            return new Cookie(name, unwrappedValue.toString());\n        }\n    ",
        "addToClassPath": "\n        try {\n            String cpComp[] = getFilesByExt(dir, \".jar\");\n            if (cpComp != null) {\n                int jarCount = cpComp.length;\n                for (int i = 0; i < jarCount; i++) {\n                    URL url = getURL(dir, cpComp[i]);\n                    if (url != null)\n                        cpV.addElement(url);\n                }\n            }\n        } catch (Exception ex) {\n            logger.debug(\"failed to add urls to classpath\", ex);\n        }\n    ",
        "createCriticalSectionPanel": "\n        JPanel conditionPanel = new JPanel(new BorderLayout(5, 0));\n\n        // Condition LABEL\n        JLabel conditionLabel = new JLabel(\n                JMeterUtils.getResString(\"critical_section_controller_label\")); // $NON-NLS-1$\n        conditionPanel.add(conditionLabel, BorderLayout.WEST);\n\n        // TEXT FIELD\n        tfLockName = new JTextField(\"\"); // $NON-NLS-1$\n        conditionLabel.setLabelFor(tfLockName);\n        conditionPanel.add(tfLockName, BorderLayout.CENTER);\n\n        conditionPanel\n                .add(Box.createHorizontalStrut(conditionLabel\n                        .getPreferredSize().width\n                        + tfLockName.getPreferredSize().width),\n                        BorderLayout.NORTH);\n\n        return conditionPanel;\n    ",
        "getNameToPattern": "\n        return nameToPattern;\n    ",
        "mapAnnotatedService": "protected abstract void mapAnnotatedService(boolean reMap, String path, AtmosphereRequest request, AtmosphereFramework.AtmosphereHandlerWrapper w)",
        "getTreeNode": "\n        return tn;\n    }\n\n    /** {@inheritDoc}",
        "properProtocol": "\n        Enumeration<String> connection = request.getHeaders(\"Connection\");\n        if (connection == null || !connection.hasMoreElements()) {\n            connection = request.getHeaders(\"connection\");\n        }\n\n        boolean isOK = false;\n        boolean isWebSocket = (request.getHeader(\"sec-websocket-version\") != null || request.getHeader(\"Sec-WebSocket-Draft\") != null);\n        if (connection != null && connection.hasMoreElements()) {\n            String[] e = connection.nextElement().split(\",\");\n            for (String upgrade : e) {\n                if (upgrade.trim().equalsIgnoreCase(\"upgrade\")) {\n                    isOK = true;\n                    break;\n                }\n            }\n        }\n        return !isWebSocket || isOK;\n    ",
        "removePrevCount": "\n        int prevCount = 0;\n        String prevString = vars.get(refName + REF_MATCH_NR);\n        if (prevString != null) {\n            // ensure old value is not left defined\n            vars.remove(refName + REF_MATCH_NR);\n            try {\n                prevCount = Integer.parseInt(prevString);\n            } catch (NumberFormatException nfe) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"{}: Could not parse number: '{}'.\", getName(), prevString);\n                }\n            }\n        }\n        return prevCount;\n    ",
        "setProperty": "\n        String setter = \"set\" + capitalize(name);\n        try {\n            Method methods[] = findMethods(object.getClass());\n            Method setPropertyMethod = null;\n            // find setFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 0) {\n                    methods[i].invoke(object, new Object[]{});\n                    return;\n                }\n            }\n        } catch (Exception e) {\n            if (dbg > 0) {\n                debug(\"Exception for \" + object.getClass() + \" \" + name);\n            }\n            if (dbg > 1) {\n                logger.debug(\"\", e);\n            }\n        }\n    }\n\n    /**\n     * Replace ${NAME",
        "getWebServerName": "\n        return framework.getAsyncSupport().getContainerName();\n    }\n\n    /**\n     * Return the list of {@link org.atmosphere.cpr.AtmosphereFramework.AtmosphereHandlerWrapper}s.\n     *\n     * @return the list of {@link org.atmosphere.cpr.AtmosphereFramework.AtmosphereHandlerWrapper",
        "readChar": "\n        return (char) readUnsignedShort();\n    ",
        "renderPath": "\n        Iterator<?> iter = path.iterator();\n        StringBuilder buf = new StringBuilder();\n        boolean first = true;\n        while (iter.hasNext()) {\n            if (first) {\n                first = false;\n                iter.next();\n                continue;\n            }\n            buf.append(iter.next());\n            if (iter.hasNext()) {\n                buf.append(SEPARATOR); // $NON-NLS-1$\n            }\n        }\n        return buf.toString();\n    }\n\n    /** {@inheritDoc}",
        "createReserved": "\n        /* TODO need to escape all regex characters present */\n        char[] reserved = {\n            '.',\n            '?',\n            '(', \n            ')'};\n\n        Set<Character> s = new HashSet<>(reserved.length);\n        for (char c : reserved) s.add(c);\n        return s;\n    ",
        "setInputVal": "\n        setProperty(new StringProperty(INPUTVAL, inputValue));\n    ",
        "processArgs": "\n        for (int i = 0; i < args.length; i++) {\n            String arg = args[i];\n            if (arg.startsWith(\"-\"))\n                arg = arg.substring(1);\n            if (aliases != null && aliases.get(arg) != null)\n                arg = aliases.get(arg);\n\n            if (args0 != null) {\n                boolean set = false;\n                for (int j = 0; j < args0.length; j++) {\n                    if (args0[j].equalsIgnoreCase(arg)) {\n                        setProperty(proxy, args0[j], \"true\");\n                        set = true;\n                        break;\n                    }\n                }\n                if (set)\n                    continue;\n            }\n            if (args1 != null) {\n                for (int j = 0; j < args1.length; j++) {\n                    if (args1[j].equalsIgnoreCase(arg)) {\n                        i++;\n                        if (i >= args.length)\n                            return false;\n                        setProperty(proxy, arg, args[i]);\n                        break;\n                    }\n                }\n            } else {\n                // if args1 is not specified,assume all other options have param\n                i++;\n                if (i >= args.length)\n                    return false;\n                setProperty(proxy, arg, args[i]);\n            }\n\n        }\n        return true;\n    ",
        "onControl": "\n        logger.trace(\"{}\", event);\n    ",
        "onStartup": "\n        final Map<Class<? extends Annotation>, Set<Class<?>>> classesByAnnotation = new HashMap<>();\n        if (classes != null) {\n            for(final Class<?> clazz : classes) {\n                for(Annotation annotation : clazz.getAnnotations()) {\n                    Set<Class<?>> classSet = classesByAnnotation.computeIfAbsent(annotation.annotationType(), k -> new HashSet<>());\n                    classSet.add(clazz);\n                }\n            }\n        }\n        servletContext.setAttribute(DefaultAnnotationProcessor.ANNOTATION_ATTRIBUTE, classesByAnnotation);\n    ",
        "check": "\n        try {\n            Class.forName(clazz);\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    ",
        "heartbeat": "\n            message.set(paddingData);\n        }\n    ",
        "awaitTermination": "\n        return false;\n    ",
        "handleException": "\n        logger.error(\"\", ex);\n        AtmosphereResource r = webSocket.resource();\n        if (r != null) {\n            webSocketHandler.onError(webSocket, new WebSocketException(ex,\n                    new AtmosphereResponseImpl.Builder()\n                            .request(((AtmosphereResourceImpl) r).getRequest(false))\n                            .status(500)\n                            .statusMessage(\"Server Error\").build()));\n        }\n    }\n\n    /**\n     * Dispatch to request/response to the {@link org.atmosphere.cpr.AsyncSupport} implementation as it was a normal HTTP request.\n     *\n     * @param request a {@link AtmosphereRequest}\n     * @param r       a {@link AtmosphereResponse",
        "testMessage": "\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/e\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        assertNotNull(r.get());\n        r.get().resume();\n        assertNotNull(message.get());\n        assertEquals(message.get(), \"message\");\n\n    ",
        "testTrackAndTryAcquire": "\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        final AtomicReference<AtmosphereSession> session = new AtomicReference<AtmosphereSession>();\n        framework.addAtmosphereHandler(\"/acquire\", new AtmosphereHandlerAdapter() {\n            @Override\n            public void onRequest(AtmosphereResource resource) throws IOException {\n                if (session.get() == null) {\n                    session.set(new AtmosphereSession(resource));\n                }\n                resource.suspend(2, TimeUnit.SECONDS);\n            }\n\n            @Override\n            public void onStateChange(AtmosphereResourceEvent event) throws IOException {\n                latch.countDown();\n            }\n        });\n        final String qs = \"&X-Atmosphere-tracking-id=c8834462-c46e-4dad-a22f-b86aabe3f883&X-Atmosphere-Framework=2.0.4-javascript&X-Atmosphere-Transport=sse&X-Atmosphere-TrackMessageSize=true&X-atmo-protocol=true&_=1380799455333\";\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().queryString(qs).pathInfo(\"/acquire\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n\n        latch.await(10, TimeUnit.SECONDS);\n        assertNull(session.get().acquire());\n\n        final AtomicReference<AtmosphereResource> rrr = new AtomicReference<AtmosphereResource>();\n        final CountDownLatch _latch = new CountDownLatch(1);\n        framework.addAtmosphereHandler(\"/acquire\", new AtmosphereHandlerAdapter() {\n            @Override\n            public void onRequest(final AtmosphereResource resource) throws IOException {\n                resource.suspend(2, TimeUnit.SECONDS);\n            }\n\n            @Override\n            public void onStateChange(AtmosphereResourceEvent event) throws IOException {\n                try {\n                    rrr.set(session.get().tryAcquire());\n                    _latch.countDown();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        request = new AtmosphereRequestImpl.Builder().queryString(qs).pathInfo(\"/acquire\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance(request));\n\n        _latch.await(10, TimeUnit.SECONDS);\n\n        assertNotNull(rrr.get());\n\n        new Thread() {\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                    AtmosphereRequest request = new AtmosphereRequestImpl.Builder().queryString(qs).pathInfo(\"/acquire\").build();\n                    framework.doCometSupport(request, AtmosphereResponseImpl.newInstance(request));\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n\n        assertNotNull(session.get().tryAcquire());\n\n\n    ",
        "writePadding": "\n        if (response.request() != null && response.request().getAttribute(\"paddingWritten\") != null) return false;\n\n        response.setContentType(contentType);\n        response.setCharacterEncoding(\"utf-8\");\n        boolean isUsingStream = (Boolean) response.request().getAttribute(PROPERTY_USE_STREAM);\n        if (isUsingStream) {\n            try {\n                OutputStream stream = response.getResponse().getOutputStream();\n                try {\n                    stream.write(padding);\n                    stream.flush();\n                } catch (IOException ex) {\n                    logger.warn(\"SSE may not work\", ex);\n                }\n            } catch (IOException e) {\n                logger.trace(\"\", e);\n            }\n        } else {\n            try {\n                PrintWriter w = response.getResponse().getWriter();\n                w.println(paddingText);\n                w.flush();\n            } catch (IOException e) {\n                logger.trace(\"\", e);\n            }\n        }\n        response.resource().getRequest().setAttribute(\"paddingWritten\", \"true\");\n        return true;\n    ",
        "testCloseExcludeCache": "\n        UUIDBroadcasterCache cache = new UUIDBroadcasterCache();\n        SimpleBroadcaster b = config.getBroadcasterFactory().lookup(SimpleBroadcaster.class, \"uuidTest\", true);\n        cache.configure(config);\n\n        b.getBroadcasterConfig().setBroadcasterCache(cache);\n        // Reset\n        b.removeAtmosphereResource(ar);\n\n        b.addAtmosphereResource(ar);\n        b.broadcast(\"foo\").get();\n\n        ar.close();\n        b.removeAtmosphereResource(ar);\n\n        b.broadcast(\"raide\").get();\n\n        assertEquals(cache.messages().isEmpty(), false);\n        List<Object> l = cache.retrieveFromCache(b.getID(), ar.uuid());\n        assertNotNull(l);\n        assertEquals(l.isEmpty(), false);\n    ",
        "findMethod": "\n        Method methods[] = findMethods(c);\n        if (methods == null)\n            return null;\n        for (int i = 0; i < methods.length; i++) {\n            if (methods[i].getName().equals(name)) {\n                Class<?> methodParams[] = methods[i].getParameterTypes();\n                if (methodParams == null)\n                    if (params == null || params.length == 0)\n                        return methods[i];\n                if (params == null)\n                    if (methodParams == null || methodParams.length == 0)\n                        return methods[i];\n                if (params.length != methodParams.length)\n                    continue;\n                boolean found = true;\n                for (int j = 0; j < params.length; j++) {\n                    if (params[j] != methodParams[j]) {\n                        found = false;\n                        break;\n                    }\n                }\n                if (found)\n                    return methods[i];\n            }\n        }\n        return null;\n    ",
        "resolveClass": "\n        if (genericType instanceof Class) {\n            return (Class<?>) genericType;\n        } else if (genericType instanceof ParameterizedType) {\n            return resolveClass(((ParameterizedType) genericType).getRawType(), targetType);\n        } else if (genericType instanceof GenericArrayType) {\n            GenericArrayType arrayType = (GenericArrayType) genericType;\n            Class<?> compoment = resolveClass(arrayType.getGenericComponentType(), targetType);\n            return Array.newInstance(compoment, 0).getClass();\n        } else if (genericType instanceof TypeVariable) {\n            TypeVariable<?> variable = (TypeVariable<?>) genericType;\n            genericType = getTypeVariableMap(targetType).get(variable);\n            genericType = genericType == null ? resolveBound(variable) : resolveClass(genericType,\n                    targetType);\n        }\n\n        return genericType instanceof Class ? (Class<?>) genericType : Unknown.class;\n    ",
        "resume": "\n\n        if (req.getAttribute(ATMOSPHERE) == null) {\n            return;\n        }\n\n        CometHandler handler = ctx.getCometHandler((Integer) req.getAttribute(ATMOSPHERE));\n        req.removeAttribute(ATMOSPHERE);\n\n        if (req.resource() != null) {\n            try {\n                ((AtmosphereResourceImpl) req.resource()).cancel();\n            } catch (IOException e) {\n                logger.trace(\"\", e);\n            }\n        }\n\n        if (handler != null) {\n            ctx.resumeCometHandler(handler);\n        }\n    ",
        "getWebSocketAccept": "\n\n        MessageDigest sha1Helper = sha1Helpers.poll();\n        if (sha1Helper == null) {\n            try {\n                sha1Helper = MessageDigest.getInstance(\"SHA1\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        sha1Helper.reset();\n        try {\n            sha1Helper.update(key.getBytes(\"ISO_8859_1\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new ServletException(e);\n        }\n        String result = org.apache.tomcat.util.codec.binary.Base64.encodeBase64String(sha1Helper.digest(WS_ACCEPT));\n\n        sha1Helpers.add(sha1Helper);\n\n        return result;\n    ",
        "getParentFocusPoint": "\n        return parentFocusPoint;\n    ",
        "testEmptyDestroy": "\n        Broadcaster b = framework.getBroadcasterFactory().lookup(B.class, \"/test\", true);\n        b.setBroadcasterLifeCyclePolicy(BroadcasterLifeCyclePolicy.EMPTY_DESTROY);\n        AR ah = new AR();\n\n        framework.addAtmosphereHandler(\"/*\", ah, b).init();\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/a\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        b.removeAtmosphereResource(ah.resource);\n\n        assertFalse(B.class.cast(b).releaseExternalResources.get());\n        assertTrue(B.class.cast(b).destroy.get());\n    ",
        "lookupAll": "\n            return null;\n        ",
        "getId": "\n        if (!valid.get()) throw new IllegalStateException();\n        return sessionId;\n    ",
        "setReturnVal": "\n        setProperty(new StringProperty(RETURNVAL, inputValue));\n    ",
        "excludedContentTypes": "\n        return excludedContentTypes;\n    ",
        "getRightBoundary": "\n        return getPropertyAsString(R_BOUNDARY);\n    ",
        "isBodyEmpty": "\n        if (o != null && (String.class.isAssignableFrom(o.getClass()) && ((String) o).isEmpty())) return true;\n        assert o != null;\n        return Byte[].class.isAssignableFrom(o.getClass()) && ((Byte[]) o).length == 0;\n    ",
        "next": "\n            if (!hasNext())\n                throw new NoSuchElementException();\n            return s.charAt(pos++);\n        ",
        "setServletClass": "\n        this.servletClassName = servletClass;\n    ",
        "intValue": "\n            return integer;\n        }\n    ",
        "contextualEncode": "\n        return _encode(s, t, template, true);\n    ",
        "enableCache": "\n        cacheEnabled = true;\n    ",
        "getRandomSeedAsLong": "\n        Long seed = null;\n        try {\n            seed = Long.parseLong(randomSeed);\n        } catch (NumberFormatException e) {\n            if(log.isWarnEnabled()) {\n                log.warn(\"Cannot parse random seed: '{}' in element {}\", randomSeed, getName());\n            }\n        }\n        return seed;\n    ",
        "object": "\n            return o;\n        }\n    }\n",
        "filter": "\n            return new BroadcastAction(BroadcastAction.ACTION.CONTINUE, message + msg);\n        }\n    }\n\n    public final static class AR implements AtmosphereHandler {\n\n        public AtomicReference<StringBuffer> value = new AtomicReference<StringBuffer>(new StringBuffer());\n\n        @Override\n        public void onRequest(AtmosphereResource e) throws IOException {\n        }\n\n        @Override\n        public void onStateChange(AtmosphereResourceEvent e) throws IOException {\n            value.get().append(e.getMessage());\n        }\n\n        @Override\n        public void destroy() {\n        }\n    }\n",
        "generateUuid": "String generateUuid()",
        "matchEncoder": "\n        if (instanceType == null) return null;\n\n        Object encodedObject = encoders.isEmpty() ? instanceType : null;\n        for (Encoder d : encoders) {\n            Class<?>[] typeArguments = TypeResolver.resolveArguments(d.getClass(), Encoder.class);\n            if (typeArguments.length > 0 && typeArguments[0].isAssignableFrom(instanceType.getClass())) {\n                logger.trace(\"{} is trying to encode {}\", d, instanceType);\n                encodedObject = d.encode(instanceType);\n            }\n        }\n        return encodedObject;\n    ",
        "getFileEncoding": "\n        return fileEncoding;\n    ",
        "testManagedPathMessage": "\n        instanceCount = 0;\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/test\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        assertEquals(instanceCount, 1);\n        assertNotNull(r.get());\n        assertEquals(r.get(), \"/test\");\n\n    }\n\n    @AtmosphereHandlerService(path = \"/ah/{g",
        "pathInfo": "\n        String pathInfo = null;\n        String path;\n        try {\n            pathInfo = request.getPathInfo();\n        } catch (IllegalStateException ex) {\n            // http://java.net/jira/browse/GRIZZLY-1301\n        }\n\n        if (pathInfo != null) {\n            path = request.getServletPath() + pathInfo;\n        } else {\n            path = request.getServletPath();\n        }\n\n        if (path == null || path.isEmpty()) {\n            path = \"/\";\n        }\n        return path;\n    ",
        "getReplacementElement": "\n        return sub;\n    ",
        "webSocketQueryStringPresentOrNull": "\n        String transport = request.getHeader(HeaderConfig.X_ATMOSPHERE_TRANSPORT);\n        if (transport == null) {\n            // ignore so other framework client can work\n            return true;\n        } else {\n            return transport.equalsIgnoreCase(HeaderConfig.WEBSOCKET_TRANSPORT);\n        }\n    ",
        "webSocket": "\n            return webSocket;\n        ",
        "getTimeout": "\n        return timeout;\n    ",
        "resolveGenericType": "\n        Class<?> rawType;\n        if (initialType instanceof ParameterizedType)\n            rawType = (Class<?>) ((ParameterizedType) initialType).getRawType();\n        else\n            rawType = (Class<?>) initialType;\n\n        if (targetType.equals(rawType))\n            return initialType;\n\n        Type result;\n        if (targetType.isInterface()) {\n            for (Type superInterface : rawType.getGenericInterfaces())\n                if (superInterface != null && !superInterface.equals(Object.class))\n                    if ((result = resolveGenericType(superInterface, targetType)) != null)\n                        return result;\n        }\n\n        Type superType = rawType.getGenericSuperclass();\n        if (superType != null && !superType.equals(Object.class))\n            if ((result = resolveGenericType(superType, targetType)) != null)\n                return result;\n\n        return null;\n    }\n\n    /**\n     * Resolves the raw class for the given {@code genericType}, using the type variable information\n     * from the {@code targetType",
        "w": "\n        return wMap.get(w);\n    ",
        "getCreationTime": "\n        if (!valid.get()) throw new IllegalStateException();\n        return creationTime;\n    ",
        "endsWithSlash": "\n        return endsWithSlash;\n    ",
        "invokeWebSocketProtocol": "\n    ",
        "addToCache": "\n                CacheMessage c = put(e, System.nanoTime(), uuid);\n                cachedMessage.set(messages);\n                latch.countDown();\n                return c;\n            ",
        "saveMatches": "\n        if (matchNumber >=0 && matches.isEmpty()) {\n            return 0;\n        }\n        int matchCount = 0;\n        if (matchNumber == 0) {\n            saveRandomMatch(vars, refName, matches);\n        } else if (matchNumber > 0) {\n            saveOneMatch(vars, refName, matches);\n        } else {\n            matchCount = matches.size();\n            saveAllMatches(vars, refName, matches);\n        }\n        return matchCount;\n    ",
        "getWebSocketFactory": "\n        return config.websocketFactory();\n    ",
        "metaBroadcaster": "\n        return framework.metaBroadcaster();\n    }\n\n    /**\n     * Return the {@link AtmosphereResourceSessionFactory",
        "getMaxInactiveInterval": "\n        return maxInactiveInterval;\n    ",
        "getTemplate": "\n        return template;\n    ",
        "onError": "\n        logger.trace(\"onError {}\", webSocket, t);\n    ",
        "getProperties": "\n        return properties;\n    ",
        "proxied": "\n            return proxied;\n        ",
        "setServletClassName": "\n        this.servletClassName = servletClass;\n    ",
        "startStateTracker": "\n        trackerFuture = stateTracker.scheduleAtFixedRate(() -> {\n            long now = System.currentTimeMillis();\n            for (Map.Entry<String, BroadcasterTracker> t : states.entrySet()) {\n                // The resource may still be suspended but we don't want to keep a reference to it, so we swap\n                // the state and will recover.\n                if (now - t.getValue().lastTick() > timeout) {\n                    logger.trace(\"AtmosphereResource {} state destroyed.\", t.getKey());\n                    states.remove(t.getKey());\n                }\n            }\n        }, timeout, timeout, TimeUnit.MILLISECONDS);\n    ",
        "action": "\n                try {\n                    resumed(r.getRequest(), r.getResponse());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } catch (ServletException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).addBroadcasterListener(new L());\n    ",
        "states": "\n        return states;\n    ",
        "reset": "\n        ExecutorService e = (ExecutorService) config.properties().get(ASYNC_WRITE_THREAD_POOL);\n        if (e != null) {\n            e.shutdown();\n        }\n        config.properties().remove(ASYNC_WRITE_THREAD_POOL);\n\n        e = (ExecutorService) config.properties().get(SCHEDULER_THREAD_POOL);\n        if (e != null) {\n            e.shutdown();\n        }\n        config.properties().remove(SCHEDULER_THREAD_POOL);\n\n        e = (ExecutorService) config.properties().get(BROADCASTER_THREAD_POOL);\n        if (e != null) {\n            e.shutdown();\n        }\n        config.properties().remove(BROADCASTER_THREAD_POOL);\n    ",
        "injectMethods": "\n        for (Method m : methods) {\n            for (Injectable c : introspectors) {\n                if (!pushBackInjection.contains(instance)) {\n                    try {\n                        preMethodInjection(m, instance, (Class<U>) instance.getClass());\n                        InjectIntrospector.class.cast(c).introspectMethod(m, instance);\n                        postMethodInjection(m, instance, (Class<U>) instance.getClass());\n                    } catch (Exception ex) {\n                        methodInjectionException(m, instance, (Class<U>) instance.getClass(), ex);\n                        throw ex;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param instance    the requested object.\n     * @param defaultType the type of the requested object\n     * @param framework   the {@link org.atmosphere.cpr.AtmosphereFramework",
        "resolveBound": "\n        Type[] bounds = typeVariable.getBounds();\n        if (bounds.length == 0)\n            return Unknown.class;\n\n        Type bound = bounds[0];\n        if (bound instanceof TypeVariable)\n            bound = resolveBound((TypeVariable<?>) bound);\n\n        return bound == Object.class ? Unknown.class : bound;\n    ",
        "useBody": "\n        String prop = getMatchTarget();\n        return prop.isEmpty() || USE_BODY.equalsIgnoreCase(prop);// $NON-NLS-1$\n    ",
        "broadcaster": "Class<? extends Broadcaster> broadcaster();\n\n    ",
        "testCancelAtmosphereResource": "\n        Broadcaster two = ar.getAtmosphereConfig().getBroadcasterFactory().get(DefaultBroadcaster.class, \"two\");\n        two.addAtmosphereResource(ar);\n        ar.getRequest().setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, ar);\n        ar.getAtmosphereConfig().framework().setAsyncSupport(new AsynchronousProcessor(ar.getAtmosphereConfig()) {\n            @Override\n            public Action service(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n                return Action.CONTINUE;\n            }\n        });\n\n        AsynchronousProcessor.class.cast(ar.getAtmosphereConfig().framework().getAsyncSupport()).cancelled(ar.getRequest(), ar.getResponse());\n\n        assertEquals(broadcaster.getAtmosphereResources().size(), 0);\n        assertEquals(two.getAtmosphereResources().size(), 0);\n    ",
        "getFilename": "\n        return filename;\n    ",
        "testCompletionNotAwareForStartAsync": "\n        verifyTestCompletionAwareForStartAsync(false);\n    ",
        "tesOnStateChange": "\n        final AtomicReference<AtmosphereResource> r = new AtomicReference<AtmosphereResource>();\n        final AtomicReference<AtmosphereResourceEvent> e = new AtomicReference<AtmosphereResourceEvent>();\n\n        framework.addAtmosphereHandler(\"/a\", new AtmosphereHandler() {\n            @Override\n            public void onRequest(AtmosphereResource resource) throws IOException {\n                resource.suspend();\n                r.set(resource);\n            }\n\n            @Override\n            public void onStateChange(AtmosphereResourceEvent event) throws IOException {\n                e.set(event);\n            }\n\n            @Override\n            public void destroy() {\n            }\n        });\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/a\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        r.get().resume();\n\n        assertTrue(e.get().isResuming());\n        framework.destroy();\n    ",
        "webSocketHandler": "\n        return webSocketHandler;\n    }\n\n    /**\n     * Associate an {@link AtmosphereResource} to this WebSocket\n     *\n     * @param r an {@link AtmosphereResource",
        "setFileEncoding": "\n        this.fileEncoding = fileEncoding;\n    ",
        "testCachedOnBroadcast": "\n        framework.setBroadcasterCacheClassName(UUIDBroadcasterCache.class.getName()).addAtmosphereHandler(\"/*\", new CachedAR()).init();\n\n        Map<String, String> m = new HashMap<String, String>();\n        m.put(HeaderConfig.X_ATMOSPHERE_TRACKING_ID, UUID.randomUUID().toString());\n        m.put(HeaderConfig.X_ATMOSPHERE_TRANSPORT, HeaderConfig.LONG_POLLING_TRANSPORT);\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().headers(m).pathInfo(\"/a\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        assertEquals(CachedAR.count.get(), 3);\n    ",
        "cancelled": "\n\n        logger.trace(\"Cancelling {}\", req);\n        final AtmosphereResourceImpl r = (AtmosphereResourceImpl) req.resource();\n        // Leave a chance to the client to send the disconnect message before processing the connection\n        if (closingTime > 0) {\n            ExecutorsFactory.getScheduler(config).schedule(() -> {\n                endRequest(r, true);\n                return null;\n            }, closingTime, TimeUnit.MILLISECONDS);\n        } else {\n            if (completeLifecycle(req.resource(), true)) {\n                config.framework().notify(Action.TYPE.CANCELLED, req, res);\n            }\n        }\n        return cancelledAction;\n    ",
        "getReturnVal": "\n        getProperty(RETURNVAL).recoverRunningVersion(null);\n        return getReturnValString();\n    ",
        "getAtmosphereConfig": "\n        return config;\n    ",
        "removeAllAtmosphereResource": "\n\n        ",
        "setFilter": "\n        this.filter = filter;\n    }\n\n    /**\n     * Set the {@link Filter",
        "decodePath": "\n        List<PathSegmentImpl> segments = new LinkedList<>();\n\n        if (path == null) {\n            return segments;\n        }\n\n        int s;\n        int e = -1;\n        do {\n            s = e + 1;\n            e = path.indexOf('/', s);\n\n            if (e > s) {\n                decodePathSegment(segments, path.substring(s, e), decode);\n            } else if (e == s) {\n                segments.add(PathSegmentImpl.EMPTY_PATH_SEGMENT);\n            }\n        } while (e != -1);\n        if (s < path.length()) {\n            decodePathSegment(segments, path.substring(s), decode);\n        } else {\n            segments.add(PathSegmentImpl.EMPTY_PATH_SEGMENT);\n        }\n        return segments;\n    ",
        "replaceProperties": "\n        if (value.indexOf(\"$\") < 0) {\n            return value;\n        }\n        StringBuilder sb = new StringBuilder();\n        int prev = 0;\n        // assert value!=nil\n        int pos;\n        while ((pos = value.indexOf(\"$\", prev)) >= 0) {\n            if (pos > 0) {\n                sb.append(value.substring(prev, pos));\n            }\n            if (pos == (value.length() - 1)) {\n                sb.append('$');\n                prev = pos + 1;\n            } else if (value.charAt(pos + 1) != '{') {\n                sb.append('$');\n                prev = pos + 1; // XXX\n            } else {\n                int endName = value.indexOf('}', pos);\n                if (endName < 0) {\n                    sb.append(value.substring(pos));\n                    prev = value.length();\n                    continue;\n                }\n                String n = value.substring(pos + 2, endName);\n                String v = null;\n                if (staticProp != null) {\n                    v = staticProp.get(n);\n                }\n                if (v == null && dynamicProp != null) {\n                    for (int i = 0; i < dynamicProp.length; i++) {\n                        v = dynamicProp[i].getProperty(n);\n                        if (v != null) {\n                            break;\n                        }\n                    }\n                }\n                if (v == null)\n                    v = \"${\" + n + \"}\";\n\n                sb.append(v);\n                prev = endName + 1;\n            }\n        }\n        if (prev < value.length())\n            sb.append(value.substring(prev));\n        return sb.toString();\n    ",
        "testNormalQueryStringBuilder": "\n        framework.addAtmosphereHandler(\"/a\", new AbstractReflectorAtmosphereHandler() {\n            @Override\n            public void onRequest(AtmosphereResource resource) throws IOException {\n            }\n\n            @Override\n            public void destroy() {\n            }\n        });\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/a\").build();\n        request.queryString(\"a=b\");\n\n        final AtomicReference<String> e = new AtomicReference<String>();\n\n        framework.interceptor(new AtmosphereInterceptor() {\n            @Override\n            public void configure(AtmosphereConfig config) {\n            }\n\n            @Override\n            public Action inspect(AtmosphereResource r) {\n                e.set(r.getRequest().getQueryString());\n                return Action.CANCELLED;\n            }\n\n            @Override\n            public void postInspect(AtmosphereResource r) {\n            }\n\n            @Override\n            public void destroy() {\n\n            }\n        });\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n\n        assertEquals(e.get(), \"a=b\");\n    ",
        "createUriPattern": "\n        return new UriPattern(templateParser.getPattern(), templateParser.getGroupIndexes()); \n    ",
        "supportedType": "\n        return (t instanceof Class) && WebSocketFactory.class.isAssignableFrom((Class) t);\n    ",
        "validateAttributeValue": "\n        if (value == null) {\n            return null;\n        }\n        value = value.trim();\n        if (value.isEmpty()) {\n            return null;\n        }\n        int i = firstInvalidOctet(value, VALID_COOKIE_ATTRIBUTE_VALUE_OCTETS);\n        if (i != -1) {\n            throw new IllegalArgumentException(name + \" contains the prohibited characters: \" + value.charAt(i));\n        }\n        return value;\n    ",
        "getBoolean": "\n        try {\n            return obj.getBoolean(key);\n        } catch (JSONException e) {\n            return false;\n        }\n    ",
        "onResume": "\n                resumed.set(true);\n            }\n        ",
        "createURIComponent": "\n        if (template.indexOf('{') == -1) {\n            b.append(template);\n            return offset;\n        }\n\n        // Find all template variables\n        template = new UriTemplateParser(template).getNormalizedTemplate();\n        final Matcher m = TEMPLATE_NAMES_PATTERN.matcher(template);\n        int v = offset;\n        int i = 0;\n        while(m.find()) {\n            b.append(template, i, m.start());\n            final String tVariable = m.group(1);\n            // Check if a template variable has already occurred\n            // If so use the value to ensure that two or more declarations of \n            // a template variable have the same value\n            String tValue = mapValues.get(tVariable);\n            if (tValue != null) {\n                b.append(tValue);\n            } else if (v < values.length) {\n                tValue = values[v++];\n                if (tValue != null) {\n                    if (encode)\n                        tValue = UriComponent.encode(tValue, t);\n                    else\n                        tValue = UriComponent.contextualEncode(tValue, t);\n                    mapValues.put(tVariable, tValue);\n                    b.append(tValue);\n                } else {\n                    throw templateVariableHasNoValue(tVariable);\n                }\n            } else {\n                throw templateVariableHasNoValue(tVariable);\n            }\n            i = m.end();\n        }\n        b.append(template, i, template.length());\n        return v;\n    ",
        "destroy": "\n        }\n    }\n",
        "testMixedPerRequestFilter": "\n        broadcaster.getBroadcasterConfig().addFilter(new Filter(\"1\"));\n        broadcaster.getBroadcasterConfig().addFilter(new DoNohingFilter(\"a\"));\n        broadcaster.getBroadcasterConfig().addFilter(new Filter(\"2\"));\n        broadcaster.getBroadcasterConfig().addFilter(new DoNohingFilter(\"b\"));\n        broadcaster.getBroadcasterConfig().addFilter(new Filter(\"3\"));\n        broadcaster.getBroadcasterConfig().addFilter(new DoNohingFilter(\"c\"));\n        broadcaster.getBroadcasterConfig().addFilter(new Filter(\"4\"));\n\n        broadcaster.broadcast(\"0\").get();\n        assertEquals(atmosphereHandler.value.get().toString(), \"01a2b3c4\");\n    ",
        "getAtmosphereResourceFactory": "\n        return config.resourcesFactory();\n    ",
        "getReplacementSubTree": "\n        HashTree tree = new ListedHashTree();\n        if (selectedNode != null) {\n            // Use a local variable to avoid replacing reference by modified clone (see Bug 54950)\n            JMeterTreeNode nodeToReplace = selectedNode;\n            // We clone to avoid enabling existing node\n            if (!nodeToReplace.isEnabled()) {\n                nodeToReplace = cloneTreeNode(selectedNode);\n                nodeToReplace.setEnabled(true);\n            }\n            HashTree subtree = tree.add(nodeToReplace);\n            createSubTree(subtree, nodeToReplace);\n        }\n        return tree;\n    ",
        "createURI": "\n\n        String[] stringValues = new String[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (values[i] != null)\n                stringValues[i] = values[i].toString();\n        }\n\n        return createURIWithStringValues(\n                scheme, authority,\n                userInfo, host, port, path, query, fragment,\n                stringValues, encode);\n    ",
        "removeAttribute": "\n        if (!valid.get()) throw new IllegalStateException();\n        attributes.remove(name);\n    ",
        "forceReadEntirelyAsByte": "\n        AtmosphereRequest request = r.getRequest();\n\n        AtmosphereRequestImpl.Body body = request.body();\n        if (request.body().isEmpty()) {\n            BufferedInputStream bufferedStream = null;\n            ByteArrayOutputStream bbIS = new ByteArrayOutputStream();\n            try {\n                try {\n                    InputStream inputStream = request.getInputStream();\n                    if (inputStream != null) {\n                        bufferedStream = new BufferedInputStream(inputStream);\n                    }\n                } catch (IllegalStateException ex) {\n                    logger.trace(\"\", ex);\n                    Reader reader = request.getReader();\n                    if (reader != null) {\n                        bufferedStream = new BufferedInputStream(new ReaderInputStream(reader));\n                    }\n                }\n\n                if (bufferedStream != null) {\n                    byte[] bytes = new byte[8192];\n                    int bytesRead = 0;\n                    while (bytesRead != -1) {\n                        bytesRead = bufferedStream.read(bytes);\n                        if (bytesRead > 0)\n                            bbIS.write(bytes, 0, bytesRead);\n                    }\n\n                } else {\n                    bbIS.write(\"\".getBytes());\n                }\n            } finally {\n                if (bufferedStream != null) {\n                    try {\n                        bufferedStream.close();\n                    } catch (IOException ex) {\n                        logger.warn(\"\", ex);\n                    }\n                }\n            }\n            return bbIS.toByteArray();\n        } else if (body.hasString()) {\n            try {\n                return body.asString().getBytes(request.getCharacterEncoding());\n            } catch (UnsupportedEncodingException e) {\n                logger.error(\"\", e);\n            }\n        } else if (body.hasBytes()) {\n            return Arrays.copyOfRange(body.asBytes(), body.byteOffset(), body.byteOffset() + body.byteLength());\n        }\n        throw new IllegalStateException(\"No body \" + r);\n    ",
        "createHexTable": "\n        int[] table = new int[0x80];\n        Arrays.fill(table, -1);\n\n        for (char c = '0'; c <= '9'; c++) {\n            table[c] = c - '0';\n        }\n        for (char c = 'A'; c <= 'F'; c++) {\n            table[c] = c - 'A' + 10;\n        }\n        for (char c = 'a'; c <= 'f'; c++) {\n            table[c] = c - 'a' + 10;\n        }\n        return table;\n    ",
        "getBroadcaster": "\n        return broadcaster;\n    ",
        "escapeForJavaScript": "\n        try {\n            str = StringEscapeUtils.escapeJavaScript(str);\n        } catch (Exception e) {\n            logger.error(\"Failed to escape\", e);\n            str = \"\";\n        }\n        return str;\n    ",
        "testMultipleMessageLengthFilter": "\n        HashMap<String, String> m = new HashMap<String, String>();\n        m.put(HeaderConfig.X_ATMOSPHERE_TRACKMESSAGESIZE, \"true\");\n        AtmosphereRequest req = new AtmosphereRequestImpl.Builder().headers(m).build();\n        for (int i = 0; i < 10; i++) {\n            broadcaster.addAtmosphereResource(new AtmosphereResourceImpl(ar.getAtmosphereConfig(),\n                    broadcaster,\n                    req,\n                    AtmosphereResponseImpl.newInstance(),\n                    mock(BlockingIOCometSupport.class),\n                    new AR()));\n        }\n\n        broadcaster.getBroadcasterConfig().addFilter(new TrackMessageSizeFilter());\n        broadcaster.broadcast(\"0\").get();\n        assertEquals(atmosphereHandler.value.get().toString(), \"1|0\");\n    ",
        "maxInactiveTime": "\n        this.maxInactiveTime = maxInactiveTime;\n        start();\n        return this;\n    ",
        "map": "U map(String path, Map<String, U> handlers)",
        "unwrapValue": "\n        final int len = cs.length();\n        if (len > 0 && cs.charAt(0) == '\"') {\n            if (len >= 2 && cs.charAt(len - 1) == '\"') {\n                // properly balanced\n                return len == 2 ? \"\" : cs.subSequence(1, len - 1);\n            } else {\n                return null;\n            }\n        }\n        return cs;\n    ",
        "testAtmosphereResourceCancel": "\n        Broadcaster two = ar.getAtmosphereConfig().getBroadcasterFactory().get(DefaultBroadcaster.class, \"two\");\n        two.addAtmosphereResource(ar);\n\n        AtmosphereResourceImpl.class.cast(ar).cancel();\n        AtmosphereResourceImpl.class.cast(ar)._destroy();\n\n        assertEquals(broadcaster.getAtmosphereResources().size(), 0);\n        assertEquals(two.getAtmosphereResources().size(), 0);\n    ",
        "testCancelParentUUID": "\n        framework.addAtmosphereHandler(\"/a\", new AbstractReflectorAtmosphereHandler() {\n            @Override\n            public void onRequest(AtmosphereResource resource) throws IOException {\n            }\n\n            @Override\n            public void destroy() {\n            }\n        });\n\n        final AtmosphereRequest parentRequest = new AtmosphereRequestImpl.Builder().pathInfo(\"/a\").queryString(HeaderConfig.WEBSOCKET_X_ATMOSPHERE_TRANSPORT).build();\n        final CountDownLatch suspended = new CountDownLatch(1);\n\n        framework.interceptor(new AtmosphereInterceptor() {\n            @Override\n            public void configure(AtmosphereConfig config) {\n            }\n\n            @Override\n            public Action inspect(AtmosphereResource r) {\n                try {\n                    r.getBroadcaster().addAtmosphereResource(r);\n                    if (suspended.getCount() == 1) {\n                        r.suspend();\n                        return Action.SUSPEND;\n                    } else {\n                        return Action.CONTINUE;\n                    }\n                } finally {\n                    suspended.countDown();\n                }\n            }\n\n            @Override\n            public void destroy() {\n            }\n\n            @Override\n            public void postInspect(AtmosphereResource r) {\n            }\n        });\n\n        new Thread() {\n            public void run() {\n                try {\n                    framework.doCometSupport(parentRequest, AtmosphereResponseImpl.newInstance().request(parentRequest));\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } catch (ServletException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n\n        suspended.await();\n        Map<String, Object> m = new HashMap<String, Object>();\n        m.put(SUSPENDED_ATMOSPHERE_RESOURCE_UUID, parentRequest.resource().uuid());\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().attributes(m).pathInfo(\"/a\").queryString(HeaderConfig.WEBSOCKET_X_ATMOSPHERE_TRANSPORT).build();\n        request.setAttribute(FrameworkConfig.WEBSOCKET_MESSAGE, \"true\");\n\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance().request(request));\n\n        AtmosphereResource r = parentRequest.resource();\n        Broadcaster b = r.getBroadcaster();\n\n        assertEquals(b.getAtmosphereResources().size(), 1);\n\n        AtmosphereResourceImpl.class.cast(r).cancel();\n\n        assertEquals(b.getAtmosphereResources().size(), 0);\n\n    ",
        "isRunningJavaWebStart": "\n        boolean hasJNLP;\n        try {\n            Class.forName(\"javax.jnlp.ServiceManager\");\n            hasJNLP = true;\n        } catch (ClassNotFoundException ex) {\n            hasJNLP = false;\n        }\n        return hasJNLP;\n    ",
        "broadcastReceivedMessage": "\n        try {\n            Object newMsg = filter(message);\n            // if newSgw == null, that means the message has been filtered.\n            if (newMsg != null) {\n                push(new Deliver(newMsg, new BroadcasterFuture<Object>(newMsg), message));\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to push message: \" + message, t);\n        }\n    ",
        "supportWebSocket": "@link org.atmosphere.cpr.AtmosphereResource}\n     * @param r {@link org.atmosphere.cpr.AtmosphereResource",
        "getRawVersion": "\n        return version;\n    ",
        "guestServletPath": "\n        String servletPath = \"\";\n        if (config.getServletConfig() != null) {\n            servletPath = getCleanedServletPath(guestRawServletPath(config));\n        } else {\n            throw new IllegalStateException(\"Unable to configure jsr356 at that stage\");\n        }\n        return servletPath;\n    ",
        "testCache": "\n        broadcaster.getBroadcasterConfig().setBroadcasterCache(new AbstractBroadcasterCache() {\n            @Override\n            public CacheMessage addToCache(String id, String uuid, BroadcastMessage e) {\n                CacheMessage c = put(e, System.nanoTime(), uuid);\n                cachedMessage.set(messages);\n                return c;\n            }\n\n            @Override\n            public List<Object> retrieveFromCache(String id, String uuid) {\n                return Collections.<Object>emptyList();\n            }\n        }).getBroadcasterCache().inspector(new BroadcasterCacheInspector() {\n            @Override\n            public boolean inspect(BroadcastMessage message) {\n                return true;\n            }\n        });\n\n        broadcaster.broadcast(\"foo\", ar).get();\n        assertEquals(cachedMessage.get().size(), 0);\n    ",
        "processLiteralCharacters": "\n        if (literalCharactersBuffer.length() > 0) {\n            literalCharacters += literalCharactersBuffer.length();\n\n            String s = encodeLiteralCharacters(literalCharactersBuffer.toString());\n\n            normalizedTemplate.append(s);\n\n            // Escape if reserved regex character\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                if (RESERVED_REGEX_CHARACTERS.contains(c))\n                    regex.append(\"\\\\\");\n                regex.append(c);\n            }\n\n            literalCharactersBuffer.setLength(0);\n        }\n    ",
        "createBroadcaster": "\n        return createBroadcaster(clazz, \"POOLED\");\n    }\n\n    /**\n     * Set to true to enable tracking of {@link org.atmosphere.cpr.Broadcaster#getID()} duplication. Enabling this\n     * feature will significantly reduce the performance of the {@link org.atmosphere.pool.PoolableProvider}. Use the\n     * {@link org.atmosphere.cpr.DefaultBroadcasterFactory",
        "testCompletionAwareForSync": "\n        verifyTestCompletionAwareForSync(true);\n    ",
        "method": "\n        this.method = method;\n        return this;\n    ",
        "escapeDoubleQuotes": "\n\n        if (s == null || s.length() == 0 || s.indexOf('\"') == -1) {\n            return s;\n        }\n\n        StringBuilder b = new StringBuilder();\n        for (int i = 1; i < endIndex; i++) {\n            char c = s.charAt(i);\n            if (c == '\\\\') {\n                b.append(c);\n                //ignore the character after an escape, just append it\n                if (++i >= endIndex) {\n                    throw new IllegalArgumentException(\"Invalid escape character in cookie value.\");\n                }\n                b.append(s.charAt(i));\n            } else if (c == '\"') {\n                b.append('\\\\').append('\"');\n            } else {\n                b.append(c);\n            }\n        }\n\n        return b.toString();\n    }\n\n    ///// Server-Side Cookie Decoding code forked from io.netty/netty and modified /////\n\n    /*\n     * Copyright 2018 The Netty Project\n     *\n     * The Netty Project licenses this file to you under the Apache License,\n     * version 2.0 (the \"License\"); you may not use this file except in compliance\n     * with the License. You may obtain a copy of the License at:\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n     * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n     * License for the specific language governing permissions and limitations\n     * under the License.\n     */\n    // token = 1*<any CHAR except CTLs or separators>\n    // separators = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n    // | \",\" | \";\" | \":\" | \"\\\" | <\">\n    // | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n    // | \"{\" | \"",
        "onResult": "\n            semaphore.release();\n            if (!result.isOK() || result.getException() != null) {\n                logger.trace(\"WebSocket {} failed to write {}\", r, message);\n                if (r != null) {\n                    Broadcaster b = r.getBroadcaster();\n                    b.getBroadcasterConfig().getBroadcasterCache().addToCache(b.getID(), r.uuid(), new BroadcastMessage(message));\n                }\n            }\n        }\n    }\n",
        "injectCacheHeaders": "\n        this.injectCacheHeaders = injectCacheHeaders;\n        return this;\n    ",
        "setRefName": "\n        setProperty(REFNAME, refName);\n    ",
        "getNames": "\n        return names;\n    ",
        "trackSynchronously": "\n        httpRequest.request(urlBuildingStrategy.buildURL(focusPoint));\n    ",
        "isResetInterpreter": "\n        return getPropertyAsBoolean(RESET_INTERPRETER);\n    }\n\n    /**\n     * {@inheritDoc",
        "onSocketClosed": "\n        logger.trace(\"WebSocket.onSocketClosed.\");\n        webSocketProcessor.close(webSocket, 1005);\n    ",
        "applyMethods": "\n        if (!pushBackInjection.contains(instance)) {\n            Set<Method> methods = (getInheritedPrivateMethod(defaultType));\n            injectMethods(methods, instance);\n        }\n    ",
        "initThreadLocal": "\n        return ThreadLocal.withInitial(() -> {\n            init();\n            return createRandom();\n        });\n    ",
        "doService": "Action doService(AtmosphereRequest req, AtmosphereResponse res)\n                throws IOException, ServletException",
        "testTimeoutAtmosphereResource": "\n        Broadcaster two = ar.getAtmosphereConfig().getBroadcasterFactory().get(DefaultBroadcaster.class, \"two\");\n        two.addAtmosphereResource(ar);\n        ar.getRequest().setAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE, ar);\n        ar.getAtmosphereConfig().framework().setAsyncSupport(new AsynchronousProcessor(ar.getAtmosphereConfig()) {\n            @Override\n            public Action service(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n                return Action.CONTINUE;\n            }\n        });\n\n        AsynchronousProcessor.class.cast(ar.getAtmosphereConfig().framework().getAsyncSupport()).timedout(ar.getRequest(), ar.getResponse());\n\n        assertEquals(broadcaster.getAtmosphereResources().size(), 0);\n        assertEquals(two.getAtmosphereResources().size(), 0);\n    ",
        "escapeJavaScript": "\n    escapeJavaStyleString(out, str, true, true);\n  }\n\n  /**\n   * <p>Worker method for the {@link #escapeJavaScript(String)",
        "outgoingBroadcast": "abstract public void outgoingBroadcast(Object message);\n\n    @Overrid",
        "decode": "\n            return new StringBuffer(s);\n        }\n    }\n\n    @Test\n    public void testMessage() throws IOException, ServletException, InterruptedException {\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/f\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        assertNotNull(r.get());\n        r.get().resume();\n        assertNotNull(message.get());\n        assertEquals(message.get(), \"message\");\n\n    }\n\n    @Test\n    public void testDecoder() throws IOException, ServletException, InterruptedException {\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/g\").method(\"GET\").build();\n        framework.doCometSupport(request, AtmosphereResponseImpl.newInstance());\n        assertNotNull(r.get());\n        r.get().resume();\n        assertNotNull(message.get());\n        assertEquals(message.get(), \"message\");\n\n    }\n\n    @Test\n    public void testEncoder() throws IOException, ServletException, InterruptedException {\n\n        AtmosphereRequest request = new AtmosphereRequestImpl.Builder().pathInfo(\"/h\").method(\"GET\").build();\n        AtmosphereResponse response = AtmosphereResponseImpl.newInstance();\n        final AtomicReference<String> ref = new AtomicReference();\n\n        response.asyncIOWriter(new AsyncIOWriterAdapter() {\n            @Override\n            public AsyncIOWriter write(AtmosphereResponse r, byte[] data) throws IOException {\n                ref.set(new String(data));\n                return this;\n            }\n        });\n        framework.doCometSupport(request, response);\n        assertNotNull(r.get());\n        latch.get().await(5, TimeUnit.SECONDS);\n        r.get().resume();\n        assertNotNull(message.get());\n        assertEquals(message.get(), \"message\");\n        assertEquals(ref.get(), \"message-yo!\");\n\n    }\n",
        "timeoutTest": "\n        recovery.configure(config);\n        recovery.inspect(r);\n        final AtomicBoolean resumed = new AtomicBoolean();\n        final CountDownLatch latch = new CountDownLatch(1);\n        r.addEventListener(new AtmosphereResourceEventListenerAdapter(){\n            @Override\n            public void onResume(AtmosphereResourceEvent event) {\n                resumed.set(true);\n            }\n        }).suspend();\n        latch.await(2, TimeUnit.SECONDS);\n        r.resume();\n        assertTrue(resumed.get());\n        assertEquals(recovery.states().size(), 1);\n    ",
        "computePath": "\n        return Utils.pathInfo(req);\n    ",
        "actionPerformed": "\n        boolean forceReloadData = false;\n        final Object eventSource = event.getSource();\n        if (eventSource == displayButton) {\n            actionMakeGraph();\n        } else if (eventSource == saveGraph) {\n            saveGraphToFile = true;\n            try {\n                ActionRouter.getInstance().getAction(\n                        ActionNames.SAVE_GRAPHICS,SaveGraphics.class.getName()).doAction(\n                        new ActionEvent(this,event.getID(),ActionNames.SAVE_GRAPHICS));\n            } catch (Exception e) {\n                log.error(e.getMessage());\n            }\n        } else if (eventSource == syncWithName) {\n            graphTitle.setText(getName());\n        } else if (eventSource == dynamicGraphSize) {\n            enableDynamicGraph(dynamicGraphSize.isSelected());\n        } else if (eventSource == samplerSelection) {\n            enableSamplerSelection(samplerSelection.isSelected());\n            if (!samplerSelection.isSelected()) {\n                // Force reload data\n                forceReloadData = true;\n            }\n        }\n        // Not 'else if' because forceReloadData\n        if (eventSource == applyFilterBtn || eventSource == intervalButton || forceReloadData) {\n            if (eventSource == intervalButton) {\n                intervalValue = Integer.parseInt(intervalField.getText());\n            }\n            if (eventSource == applyFilterBtn && samplerSelection.isSelected() && samplerMatchLabel.getText() != null\n                    && samplerMatchLabel.getText().length() > 0) {\n                pattern = createPattern(samplerMatchLabel.getText());\n            } else if (forceReloadData) {\n                pattern = null;\n            }\n            if (getFile() != null && getFile().length() > 0) {\n                // Reload data from file\n                clearData();\n                FilePanel filePanel = (FilePanel) getFilePanel();\n                filePanel.actionPerformed(event);\n            } else {\n                // Reload data form internal list of results\n                synchronized (lockInterval) {\n                    if (internalList.size() >= 2) {\n                        List<RespTimeGraphDataBean> tempList = new ArrayList<>();\n                        tempList.addAll(internalList);\n                        this.clearData();\n                        for (RespTimeGraphDataBean data : tempList) {\n                            SampleResult sr = new SampleResult(data.getStartTime(), data.getTime());\n                            sr.setSampleLabel(data.getSamplerLabel());\n                            this.add(sr);\n                        }\n                    }\n                }\n            }\n        }\n    ",
        "processReady": "\n        final DeliverTo deliverTo;\n        final Ready ready = onReadyMethod.getAnnotation(Ready.class);\n\n        // Keep backward compatibility\n        if (ready.value() != Ready.DELIVER_TO.RESOURCE) {\n            if (IAE == null) {\n                IAE = new IllegalArgumentException();\n            }\n\n            logger.warn(\"Since 2.2, delivery strategy must be specified with @DeliverTo, not with a value in the @Ready annotation.\", IAE);\n            deliverTo = new DeliverTo() {\n\n                @Override\n                public DELIVER_TO value() {\n                    switch (ready.value()) {\n                        case ALL:\n                            return DELIVER_TO.ALL;\n\n                        case BROADCASTER:\n                            return DELIVER_TO.BROADCASTER;\n                    }\n\n                    return null;\n                }\n\n                @Override\n                public Class<? extends Annotation> annotationType() {\n                    return null;\n                }\n            };\n        } else {\n            deliverTo = onReadyMethod.getAnnotation(DeliverTo.class);\n        }\n\n        IOUtils.deliver(message(onReadyMethod, r), deliverTo, DeliverTo.DELIVER_TO.RESOURCE, r);\n    ",
        "useRequestHeaders": "\n        return USE_REQUEST_HDRS.equalsIgnoreCase(getMatchTarget());\n    ",
        "executeAsync": "\n        return executeAsync;\n    ",
        "fieldInjectionException": "<T, U extends T> void fieldInjectionException(Field field, U instance, Class<T> clazz, Exception ex)",
        "checkContainerDefaultConfigurator": "\n            for(ServerEndpointConfig.Configurator impl : ServiceLoader.load(javax.websocket.server.ServerEndpointConfig.Configurator.class)) {\n                hasContainerDefaultConfigurator.set(Boolean.TRUE);\n                return;\n            }\n            hasContainerDefaultConfigurator.set(Boolean.FALSE);\n        }\n\n        /**\n         * Calls {@link #checkOrigin(String)"
    }