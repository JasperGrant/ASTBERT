{
    "main": "\n        if (args.length < MINARGS){\n            System.out.println(\"Please provide \"+MINARGS+\" or more arguments:\");\n            System.out.println(\"serverhost serverport filename [arg1 arg2 ...]\");\n            System.out.println(\"e.g. \");\n            System.out.println(\"localhost 9000 extras/remote.bsh apple blake 7\");\n            return;\n        }\n        String host=args[0];\n        String portString = args[1];\n        String file=args[2];\n\n        int port=Integer.parseInt(portString)+1;// convert to telnet port\n\n        System.out.println(\"Connecting to BSH server on \"+host+\":\"+portString);\n\n        try (Socket sock = new Socket(host,port);\n                InputStream is = sock.getInputStream();\n                OutputStream os = sock.getOutputStream()) {\n            SockRead sockRead = new SockRead(is);\n            sockRead.start();\n\n            sendLine(\"bsh.prompt=\\\"\\\";\", os);// Prompt is unnecessary\n\n            sendLine(\"String [] args={\", os);\n            for (int i = MINARGS; i < args.length; i++) {\n                sendLine(\"\\\"\" + args[i] + \"\\\",\\n\", os);\n            }\n            sendLine(\"};\", os);\n\n            int b;\n            try (BufferedReader fis = Files.newBufferedReader(Paths.get(file))) {\n                while ((b = fis.read()) != -1) {\n                    os.write(b);\n                }\n            }\n            sendLine(\"bsh.prompt=\\\"bsh % \\\";\", os);// Reset for other users\n            os.flush();\n            sock.shutdownOutput(); // Tell server that we are done\n            sockRead.join(); // wait for script to finish\n        }\n    ",
    "sendLine": "\n        outPipe.write(line.getBytes(StandardCharsets.UTF_8));\n        outPipe.flush();\n    ",
    "run": "\n        sendMetrics();\n    ",
    "getInitFileProperty": "\n        return INIT_FILE;\n    ",
    "getScript": "\n        return getPropertyAsString(SCRIPT);\n    ",
    "getFilename": "\n        return filename;\n    ",
    "getParameters": "\n        return getPropertyAsString(PARAMETERS);\n    ",
    "isResetInterpreter": "\n        return getPropertyAsBoolean(RESET_INTERPRETER);\n    }\n\n    /**\n     * {@inheritDoc",
    "getResult": "\n        AssertionResult result = new AssertionResult(getName());\n        BSFManager mgr =null;\n        try {\n            mgr = getManager();\n            mgr.declareBean(\"SampleResult\", response, SampleResult.class);\n            mgr.declareBean(\"AssertionResult\", result, AssertionResult.class);\n            processFileOrScript(mgr);\n            result.setError(false);\n        } catch (BSFException e) {\n            log.warn(\"Problem in BSF script\", e);\n            result.setFailure(true);\n            result.setError(true);\n            result.setFailureMessage(e.toString());\n        } finally {\n            if(mgr != null) {\n                mgr.terminate();\n            }\n        }\n        return result;\n    ",
    "clone": "\n        return super.clone();\n    ",
    "readResolve": "\n        createBarrier();\n        return this;\n    ",
    "setProperty": "\n        if (property instanceof StringProperty) {\n            final String pn = property.getName();\n            if (pn.equals(\"calcMode\")) {\n                final Object objectValue = property.getObjectValue();\n                try {\n                    final BeanInfo beanInfo = Introspector.getBeanInfo(this.getClass());\n                    final ResourceBundle rb = (ResourceBundle) beanInfo.getBeanDescriptor().getValue(GenericTestBeanCustomizer.RESOURCE_BUNDLE);\n                    for(Enum<Mode> e : Mode.CACHED_VALUES) {\n                        final String propName = e.toString();\n                        if (objectValue.equals(rb.getObject(propName))) {\n                            final int tmpMode = e.ordinal();\n                            log.debug(\"Converted {}={} to mode={} using Locale: {}\", pn, objectValue, tmpMode,\n                                    rb.getLocale());\n                            super.setProperty(pn, tmpMode);\n                            return;\n                        }\n                    }\n                    log.warn(\"Could not convert {}={} using Locale: {}\", pn, objectValue, rb.getLocale());\n                } catch (IntrospectionException e) {\n                    log.error(\"Could not find BeanInfo\", e);\n                }\n            }\n        }\n        super.setProperty(property);\n    ",
    "iterationStart": "\n        if (log.isDebugEnabled()) {\n            log.debug(\"{} iteration start {}\", Thread.currentThread().getName(), isPerIteration());//$NON-NLS-1$\n        }\n        if (isPerIteration()) {\n            setValues();\n        }\n    ",
    "initVars": "\n        String fileName = getFilename().trim();\n        setAlias(context, fileName);\n        final String names = getVariableNames();\n        if (StringUtils.isEmpty(names)) {\n            String header = server.reserveFile(fileName, getFileEncoding(), alias, true);\n            try {\n                vars = CSVSaveService.csvSplitString(header, delim.charAt(0));\n                firstLineIsNames = true;\n            } catch (IOException e) {\n                throw new IllegalArgumentException(\"Could not split CSV header line from file:\" + fileName,e);\n            }\n        } else {\n            server.reserveFile(fileName, getFileEncoding(), alias, ignoreFirstLine);\n            vars = JOrphanUtils.split(names, \",\"); // $NON-NLS-1$\n        }\n        trimVarNames(vars);\n    ",
    "setAlias": "\n        String mode = getShareMode();\n        int modeInt = CSVDataSetBeanInfo.getShareModeAsInt(mode);\n        switch(modeInt){\n            case CSVDataSetBeanInfo.SHARE_ALL:\n                this.alias = alias;\n                break;\n            case CSVDataSetBeanInfo.SHARE_GROUP:\n                this.alias = alias + \"@\" + System.identityHashCode(context.getThreadGroup());\n                break;\n            case CSVDataSetBeanInfo.SHARE_THREAD:\n                this.alias = alias + \"@\" + System.identityHashCode(context.getThread());\n                break;\n            default:\n                this.alias = alias + \"@\" + mode; // user-specified key\n                break;\n        }\n    ",
    "trimVarNames": "\n        for (int i = 0; i < varsNames.length; i++) {\n            varsNames[i] = varsNames[i].trim();\n        }\n    ",
    "setFilename": "\n        this.filename = filename;\n    ",
    "getFileEncoding": "\n        return fileEncoding;\n    ",
    "setFileEncoding": "\n        this.fileEncoding = fileEncoding;\n    ",
    "getVariableNames": "\n        return variableNames;\n    ",
    "setVariableNames": "\n        this.variableNames = variableNames;\n    ",
    "getDelimiter": "\n        return delimiter;\n    ",
    "setDelimiter": "\n        this.delimiter = delimiter;\n    ",
    "getQuotedData": "\n        return quoted;\n    ",
    "setQuotedData": "\n        this.quoted = quoted;\n    ",
    "getRecycle": "\n        return recycle;\n    ",
    "setRecycle": "\n        this.recycle = recycle;\n    ",
    "getStopThread": "\n        return stopThread;\n    ",
    "setStopThread": "\n        this.stopThread = value;\n    ",
    "getShareMode": "\n        return shareMode;\n    ",
    "setShareMode": "\n        this.shareMode = value;\n    ",
    "isIgnoreFirstLine": "\n        return ignoreFirstLine;\n    ",
    "setIgnoreFirstLine": "\n        this.ignoreFirstLine = ignoreFirstLine;\n    ",
    "getShareModeAsInt": "\n        if (mode == null || mode.length() == 0){\n            return SHARE_ALL; // default (e.g. if test plan does not have definition)\n        }\n        for (int i = 0; i < SHARE_TAGS.length; i++) {\n            if (SHARE_TAGS[i].equals(mode)) {\n                return i;\n            }\n        }\n        return -1;\n    ",
    "getShareTags": "\n        String[] copy = new String[SHARE_TAGS.length];\n        System.arraycopy(SHARE_TAGS, 0, copy, 0, SHARE_TAGS.length);\n        return copy;\n    ",
    "getListFileEncoding": "\n        return JOrphanUtils.split(JMeterUtils.getPropDefault(\"csvdataset.file.encoding_list\", \"\"), \"|\"); //$NON-NLS-1$\n    ",
    "testEnded": "\n        testEnded(\"local\"); //$NON-NLS-1$\n    }\n\n    /**\n     * A {@link BackendListenerClient",
    "testStarted": "\n        if (log.isDebugEnabled()) {\n            log.debug(\"{}\\ttestStarted({})\", whoAmI(), host);\n        }\n\n        int queueSize;\n        final String size = getQueueSize();\n        try {\n            queueSize = Integer.parseInt(size);\n        } catch (NumberFormatException nfe) {\n            log.warn(\"Invalid queue size '{}' defaulting to {}\", size, DEFAULT_QUEUE_SIZE);\n            queueSize = Integer.parseInt(DEFAULT_QUEUE_SIZE);\n        }\n\n        synchronized (LOCK) {\n            myName = getName();\n            listenerClientData = queuesByTestElementName.get(myName);\n            if (listenerClientData == null) {\n                // We need to do this to ensure in Distributed testing\n                // that only 1 instance of BackendListenerClient is used\n                clientClass = initClass(); // may be null\n                BackendListenerClient backendListenerClient = createBackendListenerClientImpl(clientClass);\n                BackendListenerContext context = new BackendListenerContext((Arguments) getArguments().clone());\n\n                listenerClientData = new ListenerClientData();\n                listenerClientData.queue = new ArrayBlockingQueue<>(queueSize);\n                listenerClientData.queueWaits = new LongAdder();\n                listenerClientData.queueWaitTime = new LongAdder();\n                listenerClientData.latch = new CountDownLatch(1);\n                listenerClientData.client = backendListenerClient;\n                if (log.isInfoEnabled()) {\n                    log.info(\"{}: Starting worker with class: {} and queue capacity: {}\", getName(), clientClass,\n                            getQueueSize());\n                }\n                Worker worker = new Worker(backendListenerClient, (Arguments) getArguments().clone(), listenerClientData);\n                worker.setDaemon(true);\n                worker.start();\n                if (log.isInfoEnabled()) {\n                    log.info(\"{}: Started  worker with class: {}\", getName(), clientClass);\n                }\n                try {\n                    backendListenerClient.setupTest(context);\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Failed calling setupTest\", e);\n                }\n                queuesByTestElementName.put(myName, listenerClientData);\n            }\n            listenerClientData.instanceCount++;\n        }\n    ",
    "getEndIndex": "\n        // Although the default is not the same as for the string value, it is only used internally\n        return getPropertyAsInt(END_INDEX, Integer.MAX_VALUE);\n    ",
    "setEndIndex": "\n        setProperty(END_INDEX, endIndex, INDEX_DEFAULT_VALUE);\n    ",
    "getStartIndex": "\n        // Although the default is not the same as for the string value, it is only used internally\n        return getPropertyAsInt(START_INDEX, 0);\n    ",
    "setStartIndex": "\n        setProperty(START_INDEX, startIndex, INDEX_DEFAULT_VALUE);\n    ",
    "getPreload": "\n        return preload;\n    ",
    "setPreload": "\n        this.preload = preload;\n    ",
    "getClientCertAliasVarName": "\n        return clientCertAliasVarName;\n    ",
    "setClientCertAliasVarName": "\n        this.clientCertAliasVarName = clientCertAliasVarName;\n    ",
    "initThreadLocal": "\n        return ThreadLocal.withInitial(() -> {\n            init();\n            return createRandom();\n        });\n    ",
    "init": "void init()",
    "formatNumber": "\n        String format = getFormat();\n        if (format != null && format.length() > 0) {\n            try {\n                DecimalFormat myFormatter = new DecimalFormat(format);\n                return myFormatter.format(value);\n            } catch (IllegalArgumentException ignored) {\n                log.warn(\"Error formatting {} at format {}, using default\", value, format);\n            }\n        }\n        return Long.toString(value);\n    ",
    "getMinimumValue": "\n        return minimumValue;\n    ",
    "setMinimumValue": "\n        this.minimumValue = minValue;\n    ",
    "getMaximumValue": "\n        return maximumValue;\n    ",
    "setMaximumValue": "\n        this.maximumValue = maxvalue;\n    ",
    "getVariableName": "\n        return variableName;\n    ",
    "setVariableName": "\n        this.variableName = variableName;\n    ",
    "getRandomSeed": "\n        return randomSeed;\n    ",
    "createRandom": "\n        if (randomSeed.length()>0){\n            Long seed = getRandomSeedAsLong();\n            if(seed != null) {\n                return new Random(seed);\n            }\n        }\n        return new Random();\n    ",
    "getRandomSeedAsLong": "\n        Long seed = null;\n        try {\n            seed = Long.parseLong(randomSeed);\n        } catch (NumberFormatException e) {\n            if(log.isWarnEnabled()) {\n                log.warn(\"Cannot parse random seed: '{}' in element {}\", randomSeed, getName());\n            }\n        }\n        return seed;\n    ",
    "setRandomSeed": "\n        this.randomSeed = randomSeed;\n    ",
    "getPerThread": "\n        return perThread;\n    ",
    "setPerThread": "\n        setProperty(new BooleanProperty(PERTHREAD, perThread));\n    ",
    "getOutputFormat": "\n        return outputFormat;\n    ",
    "setOutputFormat": "\n        this.outputFormat = outputFormat;\n    ",
    "threadStarted": "\n        if(getGroupSize() == 0) {\n            int numThreadsInGroup = JMeterContextService.getContext().getThreadGroup().getNumThreads();\n            // Unique Barrier creation ensured by synchronized setup\n            this.barrier.setup(numThreadsInGroup);\n        }\n    ",
    "threadFinished": "\n        // NOOP\n    ",
    "setLockName": "\n        setProperty(new StringProperty(LOCK_NAME, name));\n    }\n\n    /**\n     * If lock exists returns it, otherwise creates one, puts it in LOCK_MAP\n     * then returns it\n     *\n     * @return {@link ReentrantLock",
    "getOrCreateLock": "\n        String lockName = getLockName();\n        ReentrantLock lock = LOCK_MAP.get(lockName);\n        ReentrantLock prev;\n        if (lock != null) {\n            return lock;\n        }\n        lock = new ReentrantLock();\n        prev = LOCK_MAP.putIfAbsent(lockName, lock);\n        return prev == null ? lock : prev;\n    ",
    "getLockName": "\n        return getPropertyAsString(LOCK_NAME);\n    ",
    "next": "double next()",
    "reInitialize": "\n        super.reInitialize();\n        this.reorder();\n    ",
    "getStartIndexAsString": "\n        return getPropertyAsString(START_INDEX, INDEX_DEFAULT_VALUE);\n    ",
    "getEndIndexAsString": "\n        return getPropertyAsString(END_INDEX, INDEX_DEFAULT_VALUE);\n    ",
    "setInputVal": "\n        setProperty(new StringProperty(INPUTVAL, inputValue));\n    ",
    "getInputVal": "\n        getProperty(INPUTVAL).recoverRunningVersion(null);\n        return getInputValString();\n    ",
    "getInputValString": "\n        return getPropertyAsString(INPUTVAL);\n    ",
    "setReturnVal": "\n        setProperty(new StringProperty(RETURNVAL, inputValue));\n    ",
    "getReturnVal": "\n        getProperty(RETURNVAL).recoverRunningVersion(null);\n        return getReturnValString();\n    ",
    "getReturnValString": "\n        return getPropertyAsString(RETURNVAL);\n    ",
    "getSeparator": "\n        return getUseSeparator() ? DEFAULT_SEPARATOR : \"\";// $NON-NLS-1$\n    ",
    "setUseSeparator": "\n        setProperty(new BooleanProperty(USE_SEPARATOR, b));\n    ",
    "getUseSeparator": "\n        return getPropertyAsBoolean(USE_SEPARATOR, true);\n    }\n\n    /**\n     * {@inheritDoc",
    "isDone": "\n        return subControllersAndSamplers.isEmpty()\n                ||\n                (\n                        (getStyle() == BYNUMBER\n                            && (\n                            (getExecutions() >= getMaxThroughputAsInt()\n                            && current >= getSubControllers().size())\n                            || (getMaxThroughputAsInt() == 0)))\n                        || (getStyle() == BYPERCENT\n                            && Float.compare(getPercentThroughputAsFloat(), 0.0f)==0)\n                        );\n    ",
    "endOfArguments": "\n        JMeterContext context = getThreadContext();\n        String inputVariable = getInputVal() + getSeparator() + (loopCount + 1);\n        if (context.getVariables().getObject(inputVariable) != null) {\n            if(log.isDebugEnabled()) {\n                log.debug(\"{} : Found in vars:{}, not end of Arguments\",\n                        getName(), inputVariable);\n            }\n            return false;\n        }\n        if(log.isDebugEnabled()) {\n            log.debug(\"{} : Did not find in vars:{}, End of Arguments reached\",\n                    getName(), inputVariable);\n        }\n        return true;\n    ",
    "emptyList": "\n        JMeterContext context = getThreadContext();\n\n        StringBuilder builder = new StringBuilder(\n                getInputVal().length()+getSeparator().length()+3);\n        String inputVariable =\n                builder.append(getInputVal())\n                .append(getSeparator())\n                .append(Integer.toString(loopCount+1)).toString();\n        if (context.getVariables().getObject(inputVariable) != null) {\n            return false;\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"{} No entries found - null first entry: {}\",\n                    getName(), inputVariable);\n        }\n        return true;\n    }\n\n    /**\n     * {@inheritDoc",
    "nextIsNull": "\n        return null;\n    ",
    "incrementLoopCount": "\n        loopCount++;\n    ",
    "resetLoopCount": "\n        loopCount = getStartIndex();\n    }\n\n    /**\n     * {@inheritDoc",
    "getIterCount": "\n        return loopCount + 1;\n    }\n\n    /**\n     * {@inheritDoc",
    "triggerEndOfLoop": "\n        super.triggerEndOfLoop();\n        resetLoopCount();\n    ",
    "initialize": "\n        super.initialize();\n        this.reorder();\n    ",
    "startNextLoop": "\n        reInitialize();\n    ",
    "resetBreakLoop": "\n        if(breakLoop) {\n            breakLoop = false;\n        }\n    ",
    "breakLoop": "\n        breakLoop = true;\n        setFirst(true);\n        resetCurrent();\n        resetLoopCount();\n        recoverRunningVersion();\n    ",
    "configure": "\n        super.configure(te);\n        intervalField.setText(te.getPropertyAsString(INTERVAL, String.valueOf(DEFAULT_INTERVAL)));\n        samplerSelection.setSelected(te.getPropertyAsBoolean(SERIES_SELECTION, DEFAULT_SERIES_SELECTION));\n        samplerMatchLabel.setText(te.getPropertyAsString(SERIES_SELECTION_MATCH_LABEL, \"\")); //$NON-NLS-1$\n        caseChkBox.setSelected(te.getPropertyAsBoolean(SERIES_SELECTION_CASE_SENSITIVE, DEFAULT_CASE_SENSITIVE));\n        regexpChkBox.setSelected(te.getPropertyAsBoolean(SERIES_SELECTION_REGEXP, DEFAULT_REGEXP));\n        graphTitle.setText(te.getPropertyAsString(GRAPH_TITLE, \"\")); //$NON-NLS-1$\n        titleFontNameList.setSelectedIndex(te.getPropertyAsInt(GRAPH_TITLE_FONT_NAME, DEFAULT_TITLE_FONT_NAME));\n        titleFontSizeList.setSelectedIndex(te.getPropertyAsInt(GRAPH_TITLE_FONT_SIZE, DEFAULT_TITLE_FONT_SIZE));\n        titleFontStyleList.setSelectedIndex(te.getPropertyAsInt(GRAPH_TITLE_FONT_STYLE, DEFAULT_TITLE_FONT_STYLE));\n        strokeWidthList.setSelectedIndex(te.getPropertyAsInt(LINE_STROKE_WIDTH, DEFAULT_STROKE_WIDTH_LIST));\n        pointShapeLine.setSelectedIndex(te.getPropertyAsInt(LINE_SHAPE_POINT, DEFAULT_LINE_SHAPE_POINT));\n        dynamicGraphSize.setSelected(te.getPropertyAsBoolean(GRAPH_SIZE_DYNAMIC, DEFAULT_DYNAMIC_GRAPH_SIZE));\n        graphWidth.setText(te.getPropertyAsString(GRAPH_SIZE_WIDTH, \"\")); //$NON-NLS-1$\n        graphHeight.setText(te.getPropertyAsString(GRAPH_SIZE_HEIGHT, \"\")); //$NON-NLS-1$\n        xAxisTimeFormat.setText(te.getPropertyAsString(XAXIS_TIME_FORMAT, DEFAULT_XAXIS_TIME_FORMAT));\n        maxValueYAxisLabel.setText(te.getPropertyAsString(YAXIS_SCALE_MAX_VALUE, \"\")); //$NON-NLS-1$\n        incrScaleYAxis.setText(te.getPropertyAsString(YAXIS_INCREMENT_SCALE, \"\")); //$NON-NLS-1$\n        numberShowGrouping.setSelected(te.getPropertyAsBoolean(YAXIS_NUMBER_GROUPING, DEFAULT_NUMBER_SHOW_GROUPING));\n        legendPlacementList.setSelectedIndex(te.getPropertyAsInt(LEGEND_PLACEMENT, DEFAULT_LEGEND_PLACEMENT));\n        fontNameList.setSelectedIndex(te.getPropertyAsInt(LEGEND_FONT, DEFAULT_LEGEND_FONT));\n        fontSizeList.setSelectedIndex(te.getPropertyAsInt(LEGEND_SIZE, DEFAULT_LEGEND_SIZE));\n        fontStyleList.setSelectedIndex(te.getPropertyAsInt(LEGEND_STYLE, DEFAULT_LEGEND_STYLE));\n\n        enableSamplerSelection(samplerSelection.isSelected());\n        enableDynamicGraph(dynamicGraphSize.isSelected());\n    ",
    "createTestElement": "\n        TestElement el = new ConfigTestElement();\n        modifyTestElement(el);\n        return el;\n    ",
    "modifyTestElement": "\n        super.modifyTestElement(te);\n        te.setProperty(INTERVAL, intervalField.getText(), String.valueOf(DEFAULT_INTERVAL));\n        te.setProperty(SERIES_SELECTION, samplerSelection.isSelected(), DEFAULT_SERIES_SELECTION);\n        te.setProperty(SERIES_SELECTION_MATCH_LABEL, samplerMatchLabel.getText(), \"\"); //$NON-NLS-1$\n        te.setProperty(SERIES_SELECTION_CASE_SENSITIVE, caseChkBox.isSelected(), DEFAULT_CASE_SENSITIVE);\n        te.setProperty(SERIES_SELECTION_REGEXP, regexpChkBox.isSelected(), DEFAULT_REGEXP);\n        te.setProperty(GRAPH_TITLE, graphTitle.getText(), \"\"); //$NON-NLS-1$\n        te.setProperty(GRAPH_TITLE_FONT_NAME, titleFontNameList.getSelectedIndex(), DEFAULT_TITLE_FONT_NAME);\n        te.setProperty(GRAPH_TITLE_FONT_SIZE, titleFontSizeList.getSelectedIndex(), DEFAULT_TITLE_FONT_SIZE);\n        te.setProperty(GRAPH_TITLE_FONT_STYLE, titleFontStyleList.getSelectedIndex(), DEFAULT_TITLE_FONT_STYLE);\n        te.setProperty(LINE_STROKE_WIDTH, strokeWidthList.getSelectedIndex(), DEFAULT_STROKE_WIDTH_LIST);\n        te.setProperty(LINE_SHAPE_POINT, pointShapeLine.getSelectedIndex(), DEFAULT_LINE_SHAPE_POINT);\n        te.setProperty(GRAPH_SIZE_DYNAMIC, dynamicGraphSize.isSelected(), DEFAULT_DYNAMIC_GRAPH_SIZE);\n        te.setProperty(GRAPH_SIZE_WIDTH, graphWidth.getText(), \"\"); //$NON-NLS-1$\n        te.setProperty(GRAPH_SIZE_HEIGHT, graphHeight.getText(), \"\"); //$NON-NLS-1$\n        te.setProperty(XAXIS_TIME_FORMAT, xAxisTimeFormat.getText(), DEFAULT_XAXIS_TIME_FORMAT);\n        te.setProperty(YAXIS_SCALE_MAX_VALUE, maxValueYAxisLabel.getText(), \"\"); //$NON-NLS-1$\n        te.setProperty(YAXIS_INCREMENT_SCALE, incrScaleYAxis.getText(), \"\"); //$NON-NLS-1$\n        te.setProperty(YAXIS_NUMBER_GROUPING, numberShowGrouping.isSelected(), DEFAULT_NUMBER_SHOW_GROUPING);\n        te.setProperty(LEGEND_PLACEMENT, legendPlacementList.getSelectedIndex(), DEFAULT_LEGEND_PLACEMENT);\n        te.setProperty(LEGEND_FONT, fontNameList.getSelectedIndex(), DEFAULT_LEGEND_FONT);\n        te.setProperty(LEGEND_SIZE, fontSizeList.getSelectedIndex(), DEFAULT_LEGEND_SIZE);\n        te.setProperty(LEGEND_STYLE, fontStyleList.getSelectedIndex(), DEFAULT_LEGEND_STYLE);\n\n        // Update sub-element visibility and data reload if need\n        enableSamplerSelection(samplerSelection.isSelected());\n        enableDynamicGraph(dynamicGraphSize.isSelected());\n    ",
    "clearGui": "\n        super.clearGui();\n        intervalField.setText(String.valueOf(DEFAULT_INTERVAL));\n        samplerSelection.setSelected(DEFAULT_SERIES_SELECTION);\n        samplerMatchLabel.setText( \"\"); //$NON-NLS-1$\n        caseChkBox.setSelected(DEFAULT_CASE_SENSITIVE);\n        regexpChkBox.setSelected(DEFAULT_REGEXP);\n        graphTitle.setText(\"\"); //$NON-NLS-1$\n        titleFontNameList.setSelectedIndex(DEFAULT_TITLE_FONT_NAME);\n        titleFontSizeList.setSelectedIndex(DEFAULT_TITLE_FONT_SIZE);\n        titleFontStyleList.setSelectedIndex(DEFAULT_TITLE_FONT_STYLE);\n        strokeWidthList.setSelectedIndex(DEFAULT_STROKE_WIDTH_LIST);\n        pointShapeLine.setSelectedIndex(DEFAULT_LINE_SHAPE_POINT);\n        dynamicGraphSize.setSelected(DEFAULT_DYNAMIC_GRAPH_SIZE);\n        graphWidth.setText(\"\"); //$NON-NLS-1$\n        graphHeight.setText(\"\"); //$NON-NLS-1$\n        xAxisTimeFormat.setText(DEFAULT_XAXIS_TIME_FORMAT);\n        maxValueYAxisLabel.setText(\"\"); //$NON-NLS-1$\n        incrScaleYAxis.setText(\"\"); //$NON-NLS-1$\n        numberShowGrouping.setSelected(DEFAULT_NUMBER_SHOW_GROUPING);\n        legendPlacementList.setSelectedIndex(DEFAULT_LEGEND_PLACEMENT);\n        fontNameList.setSelectedIndex(DEFAULT_LEGEND_FONT);\n        fontSizeList.setSelectedIndex(DEFAULT_LEGEND_SIZE);\n        fontStyleList.setSelectedIndex(DEFAULT_LEGEND_STYLE);\n    ",
    "getLabelResource": "\n        return \"graph_resp_time_title\"; // $NON-NLS-1$\n    ",
    "createCriticalSectionPanel": "\n        JPanel conditionPanel = new JPanel(new BorderLayout(5, 0));\n\n        // Condition LABEL\n        JLabel conditionLabel = new JLabel(\n                JMeterUtils.getResString(\"critical_section_controller_label\")); // $NON-NLS-1$\n        conditionPanel.add(conditionLabel, BorderLayout.WEST);\n\n        // TEXT FIELD\n        tfLockName = new JTextField(\"\"); // $NON-NLS-1$\n        conditionLabel.setLabelFor(tfLockName);\n        conditionPanel.add(tfLockName, BorderLayout.CENTER);\n\n        conditionPanel\n                .add(Box.createHorizontalStrut(conditionLabel\n                        .getPreferredSize().width\n                        + tfLockName.getPreferredSize().width),\n                        BorderLayout.NORTH);\n\n        return conditionPanel;\n    ",
    "createLoopCountPanel": "\n        JPanel loopPanel = new JPanel(new MigLayout(\"fillx, wrap 2, insets 0\", \"[][fill,grow]\"));\n\n        // TEXT FIELD\n        inputVal = new JTextField(\"\", 5); // $NON-NLS-1$\n        loopPanel.add(JMeterUtils.labelFor(inputVal, \"foreach_input\"));\n        inputVal.setName(INPUT_VAL_NAME);\n        loopPanel.add(inputVal);\n\n        // TEXT FIELD\n        startIndex = new JTextField(\"\", 5); // $NON-NLS-1$\n        loopPanel.add(JMeterUtils.labelFor(startIndex, \"foreach_start_index\"));\n        startIndex.setName(START_INDEX_NAME);\n        loopPanel.add(startIndex);\n\n        // TEXT FIELD\n        endIndex = new JTextField(\"\", 5); // $NON-NLS-1$\n        loopPanel.add(JMeterUtils.labelFor(endIndex, \"foreach_end_index\"));\n        endIndex.setName(END_INDEX_NAME);\n        loopPanel.add(endIndex);\n\n        // TEXT FIELD\n        returnVal = new JTextField(\"\", 5); // $NON-NLS-1$\n        loopPanel.add(JMeterUtils.labelFor(returnVal, \"foreach_output\"));\n        returnVal.setName(RETURN_VAL_NAME);\n        loopPanel.add(returnVal);\n\n        // Checkbox\n        useSeparator = new JCheckBox(JMeterUtils.getResString(\"foreach_use_separator\"), true); // $NON-NLS-1$\n        loopPanel.add(useSeparator, \"span 2\");\n\n        return loopPanel;\n    ",
    "makeTestElement": "\n        return new IncludeController();\n    ",
    "createPopupMenu": "\n        JPopupMenu menu = new JPopupMenu();\n        MenuFactory.addEditMenu(menu, true);\n        MenuFactory.addFileMenu(menu);\n        return menu;\n    ",
    "isSelectedPathAllowed": "\n                JMeterTreeNode tn = null;\n                if (lastSelected != null && lastSelected.getUserObject() instanceof JMeterTreeNode) {\n                    tn = (JMeterTreeNode) lastSelected.getUserObject();\n                }\n                return tn != null && isTestElementAllowed(tn.getTestElement());\n            ",
    "setSelectionPath": "\n                DefaultMutableTreeNode lastSelected = (DefaultMutableTreeNode) path.getLastPathComponent();\n\n                if (isSelectedPathAllowed(lastSelected)) {\n                    super.setSelectionPath(path);\n                }\n            ",
    "setSelectionPaths": "\n                DefaultMutableTreeNode lastSelected = (DefaultMutableTreeNode) pPaths[pPaths.length-1].getLastPathComponent();\n                if (isSelectedPathAllowed(lastSelected)) {\n                    super.setSelectionPaths(pPaths);\n                }\n            ",
    "addSelectionPath": "\n                DefaultMutableTreeNode lastSelected = (DefaultMutableTreeNode) path.getLastPathComponent();\n                if (isSelectedPathAllowed(lastSelected)) {\n                    super.addSelectionPath(path);\n                }\n            ",
    "addSelectionPaths": "\n                DefaultMutableTreeNode lastSelected = (DefaultMutableTreeNode) paths[paths.length-1].getLastPathComponent();\n                if (isSelectedPathAllowed(lastSelected)) {\n                    super.addSelectionPaths(paths);\n                }\n            }\n        ",
    "renderPath": "\n        Iterator<?> iter = path.iterator();\n        StringBuilder buf = new StringBuilder();\n        boolean first = true;\n        while (iter.hasNext()) {\n            if (first) {\n                first = false;\n                iter.next();\n                continue;\n            }\n            buf.append(iter.next());\n            if (iter.hasNext()) {\n                buf.append(SEPARATOR); // $NON-NLS-1$\n            }\n        }\n        return buf.toString();\n    }\n\n    /** {@inheritDoc}",
    "isTestElementAllowed": "\n        return testElement != null\n                && !(testElement instanceof AbstractThreadGroup)\n                && !(testElement instanceof TestPlan);\n\n    }\n\n    /** {@inheritDoc}",
    "findPathInTreeModel": "\n        if (level >= testPlanPath.length) {\n            return EMPTY_TREE_NODES;\n        }\n        int childCount = parent.getChildCount();\n        JMeterTreeNode searchedTreeNode =\n                (JMeterTreeNode) testPlanPath[level];\n\n        for (int i = 0; i < childCount; i++) {\n            DefaultMutableTreeNode child = (DefaultMutableTreeNode) parent.getChildAt(i);\n            JMeterTreeNode childUserObj = (JMeterTreeNode) child.getUserObject();\n\n            if (childUserObj.equals(searchedTreeNode)) {\n                if (level == (testPlanPath.length - 1)) {\n                    return child.getPath();\n                } else {\n                    return findPathInTreeModel(level + 1, testPlanPath, child);\n                }\n            }\n        }\n        return EMPTY_TREE_NODES;\n    ",
    "focusSelectedOnTree": "\n        TreeNode[] path = selected.getPath();\n        TreeNode[] filteredPath = new TreeNode[path.length-1];\n\n        //ignore first element of path - WorkBench, (why WorkBench is appearing in the path ???)\n        System.arraycopy(path, 1, filteredPath, 0, path.length - 1);\n\n        DefaultMutableTreeNode root = (DefaultMutableTreeNode) moduleToRunTreeNodes.getModel().getRoot();\n        //treepath of test plan tree and module to run tree cannot be compared directly - moduleToRunTreeModel.getPathToRoot()\n        //custom method for finding an JMeterTreeNode element in DefaultMutableTreeNode have to be used\n        TreeNode[] dmtnPath = ModuleControllerGui.findPathInTreeModel(1, filteredPath, root);\n        if (dmtnPath.length > 0) {\n            TreePath treePath = new TreePath(dmtnPath);\n            moduleToRunTreeNodes.setSelectionPath(treePath);\n            moduleToRunTreeNodes.scrollPathToVisible(treePath);\n        }\n    ",
    "reinitialize": "\n        ((DefaultMutableTreeNode) moduleToRunTreeModel.getRoot()).removeAllChildren();\n\n        GuiPackage gp = GuiPackage.getInstance();\n        JMeterTreeNode root;\n        if (gp != null) {\n            root = (JMeterTreeNode) GuiPackage.getInstance().getTreeModel().getRoot();\n            buildTreeNodeModel(root, 0, null);\n            moduleToRunTreeModel.nodeStructureChanged((TreeNode) moduleToRunTreeModel.getRoot());\n        }\n        if (selected != null) {\n            //expand Module to run tree to selected node and set selection path to it\n            this.focusSelectedOnTree(selected);\n        }\n        if (!hasAtLeastOneController) {\n            warningLabel.setText(JMeterUtils.getResString(\"module_controller_warning_no_controller\"));\n            warningLabel.setVisible(true);\n        }\n    ",
    "buildTreeNodeModel": "\n        if (node != null) {\n            for (int i = 0; i < node.getChildCount(); i++) {\n                JMeterTreeNode cur = (JMeterTreeNode) node.getChildAt(i);\n                TestElement te = cur.getTestElement();\n                if (te instanceof TestFragmentController\n                        || te instanceof AbstractThreadGroup\n                        || (te instanceof Controller\n                                && !(te instanceof ModuleController) && level > 0)) {\n                    DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(cur);\n                    parent.add(newNode);\n                    buildTreeNodeModel(cur, level + 1, newNode);\n                    final boolean isController = te instanceof Controller\n                            && !(te instanceof ModuleController\n                                    || te instanceof AbstractThreadGroup);\n                    hasAtLeastOneController =\n                            hasAtLeastOneController || isController;\n                } else if (te instanceof TestPlan) {\n                    ((DefaultMutableTreeNode) moduleToRunTreeModel.getRoot())\n                            .setUserObject(cur);\n                    buildTreeNodeModel(cur, level,\n                            (DefaultMutableTreeNode) moduleToRunTreeModel.getRoot());\n                }\n            }\n        }\n    ",
    "actionPerformed": "\n        boolean forceReloadData = false;\n        final Object eventSource = event.getSource();\n        if (eventSource == displayButton) {\n            actionMakeGraph();\n        } else if (eventSource == saveGraph) {\n            saveGraphToFile = true;\n            try {\n                ActionRouter.getInstance().getAction(\n                        ActionNames.SAVE_GRAPHICS,SaveGraphics.class.getName()).doAction(\n                        new ActionEvent(this,event.getID(),ActionNames.SAVE_GRAPHICS));\n            } catch (Exception e) {\n                log.error(e.getMessage());\n            }\n        } else if (eventSource == syncWithName) {\n            graphTitle.setText(getName());\n        } else if (eventSource == dynamicGraphSize) {\n            enableDynamicGraph(dynamicGraphSize.isSelected());\n        } else if (eventSource == samplerSelection) {\n            enableSamplerSelection(samplerSelection.isSelected());\n            if (!samplerSelection.isSelected()) {\n                // Force reload data\n                forceReloadData = true;\n            }\n        }\n        // Not 'else if' because forceReloadData\n        if (eventSource == applyFilterBtn || eventSource == intervalButton || forceReloadData) {\n            if (eventSource == intervalButton) {\n                intervalValue = Integer.parseInt(intervalField.getText());\n            }\n            if (eventSource == applyFilterBtn && samplerSelection.isSelected() && samplerMatchLabel.getText() != null\n                    && samplerMatchLabel.getText().length() > 0) {\n                pattern = createPattern(samplerMatchLabel.getText());\n            } else if (forceReloadData) {\n                pattern = null;\n            }\n            if (getFile() != null && getFile().length() > 0) {\n                // Reload data from file\n                clearData();\n                FilePanel filePanel = (FilePanel) getFilePanel();\n                filePanel.actionPerformed(event);\n            } else {\n                // Reload data form internal list of results\n                synchronized (lockInterval) {\n                    if (internalList.size() >= 2) {\n                        List<RespTimeGraphDataBean> tempList = new ArrayList<>();\n                        tempList.addAll(internalList);\n                        this.clearData();\n                        for (RespTimeGraphDataBean data : tempList) {\n                            SampleResult sr = new SampleResult(data.getStartTime(), data.getTime());\n                            sr.setSampleLabel(data.getSamplerLabel());\n                            this.add(sr);\n                        }\n                    }\n                }\n            }\n        }\n    ",
    "expandToSelectNode": "\n        GuiPackage guiInstance = GuiPackage.getInstance();\n        JTree jTree = guiInstance.getMainFrame().getTree();\n        jTree.expandPath(new TreePath(selected.getPath()));\n        selected.setMarkedBySearch(true);\n    ",
    "getTreeCellRendererComponent": "\n\n                super.getTreeCellRendererComponent(\n                        tree, value, sel, expanded, leaf, row, phasFocus);\n\n                DefaultMutableTreeNode valueTreeNode = (DefaultMutableTreeNode) value;\n                setToolTipText(getHTML(valueTreeNode.toString(), \"<br>\", 100)); // $NON-NLS-1$\n                return this;\n            ",
    "createSwitchPanel": "\n        JPanel switchPanel = new JPanel(new BorderLayout(5, 0));\n        JLabel selectionLabel = new JLabel(JMeterUtils.getResString(SWITCH_LABEL));\n        switchValue = new JTextField(\"\"); // $NON-NLS-1$\n        selectionLabel.setLabelFor(switchValue);\n        switchPanel.add(selectionLabel, BorderLayout.WEST);\n        switchPanel.add(switchValue, BorderLayout.CENTER);\n        return switchPanel;\n    ",
    "getTreeNode": "\n        return tn;\n    }\n\n    /** {@inheritDoc}",
    "toString": "String toString()",
    "getLabel": "\n        return label;\n    ",
    "getSchema": "\n        return DebugSamplerSchema.INSTANCE;\n    ",
    "getProps": "\n        return new PropertiesAccessor<>(this, getSchema());\n    ",
    "setIncludePath": "\n        set(getSchema().getIncludePath(), jmxfile);\n    ",
    "getIncludePath": "\n        return get(getSchema().getIncludePath());\n    ",
    "getReplacementSubTree": "\n        HashTree tree = new ListedHashTree();\n        if (selectedNode != null) {\n            // Use a local variable to avoid replacing reference by modified clone (see Bug 54950)\n            JMeterTreeNode nodeToReplace = selectedNode;\n            // We clone to avoid enabling existing node\n            if (!nodeToReplace.isEnabled()) {\n                nodeToReplace = cloneTreeNode(selectedNode);\n                nodeToReplace.setEnabled(true);\n            }\n            HashTree subtree = tree.add(nodeToReplace);\n            createSubTree(subtree, nodeToReplace);\n        }\n        return tree;\n    ",
    "getReplacementElement": "\n        return sub;\n    ",
    "resolveReplacementSubTree": "\n        if (selectedNode == null) {\n            List<?> nodePathList = getNodePath();\n            if (nodePathList != null && !nodePathList.isEmpty()) {\n                traverse(context, nodePathList, 1);\n            }\n\n            if(hasReplacementOccured() && selectedNode == null) {\n                throw new JMeterStopTestException(\"ModuleController:\"\n                        + getName()\n                        + \" has no selected Controller (did you rename some element in the path to target controller?), test was shutdown as a consequence\");\n            }\n        }\n    ",
    "loadIncludedElements": "\n        // only try to load the JMX test plan if there is one\n        final String includePath = getIncludePath();\n        HashTree tree = null;\n        if (includePath != null && includePath.length() > 0) {\n            String fileName=PREFIX+includePath;\n            try {\n                File file = new File(fileName.trim());\n                final String absolutePath = file.getAbsolutePath();\n                log.info(\"loadIncludedElements -- try to load included module: {}\", absolutePath);\n                if(!file.exists() && !file.isAbsolute()){\n                    log.info(\"loadIncludedElements -failed for: {}\", absolutePath);\n                    file = new File(FileServer.getFileServer().getBaseDir(), includePath);\n                    if (log.isInfoEnabled()) {\n                        log.info(\"loadIncludedElements -Attempting to read it from: {}\", file.getAbsolutePath());\n                    }\n                    if(!file.canRead() || !file.isFile()){\n                        log.error(\"Include Controller '{}' can't load '{}' - see log for details\", this.getName(),\n                                fileName);\n                        throw new IOException(\"loadIncludedElements -failed for: \" + absolutePath +\n                                \" and \" + file.getAbsolutePath());\n                    }\n                }\n\n                tree = SaveService.loadTree(file);\n                // filter the tree for a TestFragment.\n                tree = getProperBranch(tree);\n                removeDisabledItems(tree);\n                return tree;\n            } catch (NoClassDefFoundError ex) // Allow for missing optional jars\n            {\n                String msg = \"Including file \\\"\"+ fileName\n                            + \"\\\" failed for Include Controller \\\"\"+ this.getName()\n                            +\"\\\", missing jar file\";\n                log.warn(msg, ex);\n                JMeterUtils.reportErrorToUser(msg+\" - see log for details\");\n            } catch (FileNotFoundException ex) {\n                String msg = \"File \\\"\"+ fileName\n                        + \"\\\" not found for Include Controller \\\"\"+ this.getName()+\"\\\"\";\n                JMeterUtils.reportErrorToUser(msg+\" - see log for details\");\n                log.warn(msg, ex);\n            } catch (Exception ex) {\n                String msg = \"Including file \\\"\" + fileName\n                            + \"\\\" failed for Include Controller \\\"\" + this.getName()\n                            +\"\\\", unexpected error\";\n                JMeterUtils.reportErrorToUser(msg+\" - see log for details\");\n                log.warn(msg, ex);\n            }\n        }\n        return tree;\n    ",
    "getProperBranch": "\n        for (Object o : new ArrayList<>(tree.list())) {\n            TestElement item = (TestElement) o;\n\n            //if we found a TestPlan, then we are on our way to the TestFragment\n            if (item instanceof TestPlan)\n            {\n                return getProperBranch(tree.getTree(item));\n            }\n\n            if (item instanceof TestFragmentController)\n            {\n                return tree.getTree(item);\n            }\n        }\n        log.warn(\"No Test Fragment was found in included Test Plan, returning empty HashTree\");\n        return new HashTree();\n    ",
    "removeDisabledItems": "\n        for (Object o : new ArrayList<>(tree.list())) {\n            TestElement item = (TestElement) o;\n            if (!item.isEnabled()) {\n                tree.remove(item);\n            } else {\n                removeDisabledItems(tree.getTree(item));// Recursive call\n            }\n        }\n    ",
    "setStyle": "\n        setProperty(new IntegerProperty(STYLE, style));\n    ",
    "getStyle": "\n        return getPropertyAsInt(STYLE);\n    ",
    "setInterleaveAccrossThreads": "\n        setProperty(new BooleanProperty(ACCROSS_THREADS, accrossThreads));\n    ",
    "getInterleaveAccrossThreads": "\n        return getPropertyAsBoolean(ACCROSS_THREADS, false);\n    }\n\n    /**\n     * {@inheritDoc",
    "nextIsAController": "\n        Sampler sampler = controller.next();\n        if (sampler == null) {\n            currentReturnedNull(controller);\n            return next();\n        }\n        currentReturnedAtLeastOne = true;\n        if (getStyle() == IGNORE_SUB_CONTROLLERS) {\n            incrementCurrent();\n            skipNext = true;\n        } else {\n            searchStart = null;\n        }\n        return sampler;\n    }\n\n    /**\n     * {@inheritDoc",
    "nextIsASampler": "\n        skipNext = true;\n        incrementCurrent();\n        return element;\n    }\n\n    /**\n     * If the current is null, reset and continue searching. The searchStart\n     * attribute will break us off when we start a repeat.\n     * <p>\n     * {@inheritDoc",
    "setCurrentElement": "\n        // Set the position when next is first called, and don't overwrite\n        // until reInitialize is called.\n        if (searchStart == null) {\n            searchStart = currentElement;\n        } else if (searchStart == currentElement && !stillSame) {\n            // We've gone through the whole list and are now back at the start\n            // point of our search.\n            reInitialize();\n            throw new NextIsNullException();\n        }\n    }\n\n    /**\n     * {@inheritDoc",
    "currentReturnedNull": "\n        if (c.isDone()) {\n            removeCurrentElement();\n        } else if (getStyle() == USE_SUB_CONTROLLERS) {\n            incrementCurrent();\n        }\n    ",
    "isSkipNext": "\n        return skipNext;\n    ",
    "setSkipNext": "\n        this.skipNext = skipNext;\n    }\n\n    /**\n     * {@inheritDoc",
    "incrementCurrent": "\n        current=Integer.MAX_VALUE;\n    ",
    "setSelectedNode": "\n        selectedNode = tn;\n        setNodePath();\n    }\n\n    /**\n     * Gets the {@link JMeterTreeNode",
    "getSelectedNode": "\n        if (selectedNode == null){\n            restoreSelected();\n        }\n        return selectedNode;\n    ",
    "setNodePath": "\n        List<String> nodePath = new ArrayList<>();\n        if (selectedNode != null) {\n            TreeNode[] path = selectedNode.getPath();\n            for (TreeNode node : path) {\n                nodePath.add(((JMeterTreeNode) node).getName());\n            }\n        }\n        setProperty(new CollectionProperty(NODE_PATH, nodePath));\n    ",
    "getNodePath": "\n        JMeterProperty prop = getProperty(NODE_PATH);\n        if (!(prop instanceof NullProperty)) {\n            return (List<?>) prop.getObjectValue();\n        }\n        return null;\n    ",
    "restoreSelected": "\n        GuiPackage gp = GuiPackage.getInstance();\n        if (gp != null) {\n            JMeterTreeNode root = (JMeterTreeNode) gp.getTreeModel().getRoot();\n            resolveReplacementSubTree(root);\n        }\n    }\n\n    /**\n     * {@inheritDoc",
    "hasReplacementOccured": "\n        return GuiPackage.getInstance() == null || isRunningVersion();\n    ",
    "traverse": "\n        if (node != null && nodePath.size() > level) {\n            for (int i = 0; i < node.getChildCount(); i++) {\n                JMeterTreeNode cur = (JMeterTreeNode) node.getChildAt(i);\n                // Bug55375 - don't allow selectedNode to be a ModuleController as can cause recursion\n                if (!(cur.getTestElement() instanceof ModuleController)) {\n                    if (cur.getName().equals(nodePath.get(level).toString())) {\n                        if (nodePath.size() == (level + 1)) {\n                            selectedNode = cur;\n                        }\n                        traverse(cur, nodePath, level + 1);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc",
    "createSubTree": "\n        Enumeration<?> e = node.children();\n        while (e.hasMoreElements()) {\n            JMeterTreeNode subNode = (JMeterTreeNode)e.nextElement();\n            tree.add(subNode);\n            createSubTree(tree.getTree(subNode), subNode);\n        }\n    ",
    "cloneTreeNode": "\n        JMeterTreeNode treeNode = (JMeterTreeNode) node.clone();\n        treeNode.setUserObject(((TestElement) node.getUserObject()).clone());\n        cloneChildren(treeNode, node);\n        return treeNode;\n    ",
    "cloneChildren": "\n        Enumeration<?> enumr = from.children();\n        while (enumr.hasMoreElements()) {\n            JMeterTreeNode child = (JMeterTreeNode) enumr.nextElement();\n            JMeterTreeNode childClone = (JMeterTreeNode) child.clone();\n            childClone.setUserObject(((TestElement) child.getUserObject()).clone());\n            to.add(childClone);\n            cloneChildren((JMeterTreeNode) to.getLastChild(), child);\n        }\n    ",
    "resetCurrent": "\n        if (getSubControllers().isEmpty()) {\n            current = 0;\n        } else {\n            current = ThreadLocalRandom.current().nextInt(this.getSubControllers().size());\n        }\n    ",
    "reorder": "\n        Collections.shuffle(subControllersAndSamplers);\n    ",
    "setSelection": "\n        setProperty(new StringProperty(SWITCH_VALUE, inputValue));\n    ",
    "getSelectionAsInt": "\n        getProperty(SWITCH_VALUE).recoverRunningVersion(null);\n        String sel = getSelection();\n        if (StringUtils.isEmpty(sel)) {\n            return 0;\n        } else {\n            try {\n                if(StringUtils.isNumeric(sel)) {\n                    int ret = Integer.parseInt(sel);\n                    if (ret < 0 || ret >= getSubControllers().size()) {\n                        // Out of range, we return first one\n                        ret = 0;\n                    }\n                    return ret;\n                }\n            } catch (NumberFormatException e) {\n                // it will be handled by code below\n            }\n            return scanControllerNames(sel);\n        }\n    }\n\n    /**\n     * @param sel controller name\n     * @return index of controller named sel if present, otherwise index of default if found, otherwise {@link Integer#MAX_VALUE",
    "scanControllerNames": "\n        int i = 0;\n        int defaultPos = Integer.MAX_VALUE;\n        for (TestElement el : getSubControllers()) {\n            String name = el.getName();\n            if (name.equals(sel)) {\n                return i;\n            }\n            if (name.equalsIgnoreCase(\"default\")) { //$NON-NLS-1$\n                defaultPos = i;\n            }\n            i++;\n        }\n\n        return defaultPos;\n    ",
    "getSelection": "\n        return getPropertyAsString(SWITCH_VALUE).trim();\n    ",
    "incr": "\n            return ++integer;\n        ",
    "intValue": "\n            return integer;\n        }\n    ",
    "isPerThread": "\n        return getPropertyAsBoolean(PERTHREAD);\n    ",
    "setMaxThroughput": "\n        setProperty(new StringProperty(MAXTHROUGHPUT, maxThroughput));\n    ",
    "getMaxThroughput": "\n        return getPropertyAsString(MAXTHROUGHPUT);\n    ",
    "getMaxThroughputAsInt": "\n        JMeterProperty prop = getProperty(MAXTHROUGHPUT);\n        int retVal = 1;\n        if (prop instanceof IntegerProperty) {\n            retVal = prop.getIntValue();\n        } else {\n            String valueString = prop.getStringValue();\n            try {\n                retVal = Integer.parseInt(valueString);\n            } catch (NumberFormatException e) {\n                log.warn(\"Error parsing '{}'\", valueString, e);\n            }\n        }\n        return retVal;\n    ",
    "setPercentThroughput": "\n        setProperty(new StringProperty(PERCENTTHROUGHPUT, percentThroughput));\n    ",
    "getPercentThroughput": "\n        return getPropertyAsString(PERCENTTHROUGHPUT);\n    ",
    "getPercentThroughputAsFloat": "\n        JMeterProperty prop = getProperty(PERCENTTHROUGHPUT);\n        float retVal = 100;\n        if (prop instanceof FloatProperty) {\n            retVal = prop.getFloatValue();\n        } else {\n            String valueString = prop.getStringValue();\n            try {\n                retVal = Float.parseFloat(valueString);\n            } catch (NumberFormatException e) {\n                log.warn(\"Error parsing '{}'\", valueString, e);\n            }\n        }\n        return retVal;\n    ",
    "getExecutions": "\n        if (!isPerThread()) {\n            synchronized (counterLock) {\n                return globalNumExecutions.intValue();\n            }\n        }\n        return numExecutions;\n    ",
    "decide": "\n        if (getStyle() == BYNUMBER) {\n            return executions < getMaxThroughputAsInt();\n        }\n        return (100.0 * executions + 50.0) / (iterations + 1) < getPercentThroughputAsFloat();\n    ",
    "process": "\n        try {\n            List<String> matchStrings = new ArrayList<>();\n            XPathUtil.putValuesForXPathInListUsingSaxon(textToParse, xpathExpressionField.getText(),\n                    matchStrings, extractor.getFragment(), -1, namespacesTA.getText());\n            StringBuilder builder = new StringBuilder();\n            int nbFound = matchStrings.size();\n            builder.append(\"Match count: \").append(nbFound).append(\"\\n\");\n            for (int i = 0; i < nbFound; i++) {\n                builder.append(\"Match[\").append(i+1).append(\"]=\").append(matchStrings.get(i)).append(\"\\n\");\n            }\n            return builder.toString();\n        } catch (Exception e) {\n            return \"Exception:\"+ ExceptionUtils.getStackTrace(e);\n        }\n    ",
    "removePrevCount": "\n        int prevCount = 0;\n        String prevString = vars.get(refName + REF_MATCH_NR);\n        if (prevString != null) {\n            // ensure old value is not left defined\n            vars.remove(refName + REF_MATCH_NR);\n            try {\n                prevCount = Integer.parseInt(prevString);\n            } catch (NumberFormatException nfe) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"{}: Could not parse number: '{}'.\", getName(), prevString);\n                }\n            }\n        }\n        return prevCount;\n    ",
    "extractMatches": "\n        if (isScopeVariable()) {\n            String inputString = vars.get(getVariableName());\n            if (inputString == null && log.isWarnEnabled()) {\n                log.warn(\"No variable '{}' found to process by Boundary Extractor '{}', skipping processing\",\n                        getVariableName(), getName());\n            }\n            return extract(getLeftBoundary(), getRightBoundary(), matchNumber, inputString);\n        } else {\n            Stream<String> inputs = getSampleList(previousResult).stream().map(this::getInputString);\n            return extract(getLeftBoundary(), getRightBoundary(), matchNumber, inputs);\n        }\n    }\n\n    /**\n     * @param vars {@link JMeterVariables",
    "saveMatches": "\n        if (matchNumber >=0 && matches.isEmpty()) {\n            return 0;\n        }\n        int matchCount = 0;\n        if (matchNumber == 0) {\n            saveRandomMatch(vars, refName, matches);\n        } else if (matchNumber > 0) {\n            saveOneMatch(vars, refName, matches);\n        } else {\n            matchCount = matches.size();\n            saveAllMatches(vars, refName, matches);\n        }\n        return matchCount;\n    ",
    "saveRandomMatch": "\n        String match = matches.get(JMeterUtils.getRandomInt(matches.size()));\n        if (match != null) {\n            vars.put(refName, match);\n        }\n    ",
    "saveOneMatch": "\n        if (matches.size() == 1) { // if not then invalid matchNum was likely supplied\n            String match = matches.get(0);\n            if (match != null) {\n                vars.put(refName, match);\n            }\n        }\n    ",
    "saveAllMatches": "\n        vars.put(refName + REF_MATCH_NR, Integer.toString(matches.size()));\n        for (int i = 0; i < matches.size(); i++) {\n            String match = matches.get(i);\n            if (match != null) {\n                int varNum = i + 1;\n                vars.put(refName + UNDERSCORE + varNum, match);\n            }\n        }\n    ",
    "getInputString": "\n        String inputString = useUrl() ? result.getUrlAsString() // Bug 39707\n                : useHeaders() ? result.getResponseHeaders()\n                : useRequestHeaders() ? result.getRequestHeaders()\n                : useCode() ? result.getResponseCode() // Bug 43451\n                : useMessage() ? result.getResponseMessage() // Bug 43451\n                : useUnescapedBody() ? StringEscapeUtils.unescapeHtml4(result.getResponseDataAsString())\n                : useBodyAsDocument() ? Document.getTextFromDocument(result.getResponseData())\n                : result.getResponseDataAsString() // Bug 36898\n                ;\n       log.debug(\"Input = '{}'\", inputString);\n       return inputString;\n    ",
    "chosenInput": "\n        if (useUrl()) {\n            return result.getUrlAsString(); // Bug 39707;\n        }\n        if (useHeaders()) {\n            return result.getResponseHeaders();\n        }\n        if (useRequestHeaders()) {\n            return result.getRequestHeaders();\n        }\n        if (useCode()) {\n            return result.getResponseCode(); // Bug 43451\n        }\n        if (useMessage()) {\n            return result.getResponseMessage(); // Bug 43451\n        }\n        if (useUnescapedBody()) {\n            return StringEscapeUtils.unescapeHtml4(result.getResponseDataAsString());\n        }\n        if (useBodyAsDocument()) {\n            return Document.getTextFromDocument(result.getResponseData());\n        }\n        return result.getResponseDataAsString(); // Bug 36898\n    ",
    "extract": "\n        Document document;\n        if (cacheKey != null) {\n            document = (Document)\n                    JMeterContextService.getContext().getSamplerContext().get(CACHE_KEY_PREFIX+cacheKey);\n            if(document==null) {\n                document = Jsoup.parse(inputString);\n                JMeterContextService.getContext().getSamplerContext().put(CACHE_KEY_PREFIX+cacheKey, document);\n            }\n        } else {\n            document = Jsoup.parse(inputString);\n        }\n        Elements elements = document.select(expression);\n        for (Element element : elements) {\n            if (matchNumber <= 0 || found != matchNumber) {\n                result.add(extractValue(attribute, element));\n                found++;\n            } else {\n                break;\n            }\n        }\n        return found;\n    ",
    "extractAll": "\n        return extract(leftBoundary, rightBoundary, textToParse);\n    ",
    "setRefName": "\n        setProperty(REFNAME, refName);\n    ",
    "getRefName": "\n        return getPropertyAsString(REFNAME);\n    ",
    "setMatchNumber": "\n        setProperty(MATCH_NUMBER, matchNumber);\n    ",
    "getMatchNumber": "\n        return getPropertyAsInt(MATCH_NUMBER, DEFAULT_VALUE);\n    ",
    "getMatchNumberAsString": "\n        return getPropertyAsString(MATCH_NUMBER, DEFAULT_VALUE_AS_STRING);\n    ",
    "setLeftBoundary": "\n        setProperty(L_BOUNDARY, leftBoundary);\n    ",
    "getLeftBoundary": "\n        return getPropertyAsString(L_BOUNDARY);\n    ",
    "setRightBoundary": "\n        setProperty(R_BOUNDARY, rightBoundary);\n    ",
    "getRightBoundary": "\n        return getPropertyAsString(R_BOUNDARY);\n    ",
    "setDefaultValue": "\n        setProperty(DEFAULT, val);\n    ",
    "setDefaultEmptyValue": "\n        set(getSchema().getDefaultIsEmpty(), defaultEmptyValue);\n    ",
    "getDefaultValue": "\n        return getPropertyAsString(DEFAULT);\n    ",
    "isEmptyDefaultValue": "\n        return get(getSchema().getDefaultIsEmpty());\n    ",
    "useHeaders": "\n        return USE_HDRS.equalsIgnoreCase(getMatchTarget());\n    ",
    "useRequestHeaders": "\n        return USE_REQUEST_HDRS.equalsIgnoreCase(getMatchTarget());\n    ",
    "useBody": "\n        String prop = getMatchTarget();\n        return prop.isEmpty() || USE_BODY.equalsIgnoreCase(prop);// $NON-NLS-1$\n    ",
    "useUnescapedBody": "\n        String prop = getMatchTarget();\n        return USE_BODY_UNESCAPED.equalsIgnoreCase(prop);// $NON-NLS-1$\n    ",
    "useBodyAsDocument": "\n        String prop = getMatchTarget();\n        return USE_BODY_AS_DOCUMENT.equalsIgnoreCase(prop);// $NON-NLS-1$\n    ",
    "useUrl": "\n        String prop = getMatchTarget();\n        return USE_URL.equalsIgnoreCase(prop);\n    ",
    "useCode": "\n        String prop = getMatchTarget();\n        return USE_CODE.equalsIgnoreCase(prop);\n    ",
    "useMessage": "\n        String prop = getMatchTarget();\n        return USE_MESSAGE.equalsIgnoreCase(prop);\n    ",
    "setUseField": "\n        set(getSchema().getMatchTarget(), actionCommand);\n    "
}